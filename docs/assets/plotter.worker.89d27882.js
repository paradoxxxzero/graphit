(function(){"use strict";var D={sound:{adsr:"adsr usage: (x, attack = 0.2, decay = 0.1, sustain = 0.4, release = 0.3, sustainLevel = 0.5, duration = <sound duration>)",osc:"osc usage: (x, freq, type = sine|square|smoothsquare|sawtooth|triangle|noise, smooth = 0.5)",oscs:"oscs usage: (x, freqs, type = sine|square|smoothsquare|sawtooth|triangle|noise, smooth = 0.5)",sine:"sine usage: (x, freq)",square:"square usage: (x, freq)",smoothsquare:"smoothsquare usage: (x, freq, smooth = 0.5)",sawtooth:"sawtooth usage: (x, freq)",triangle:"triangle usage: (x, freq)",noise:"noise usage: (x)",lowpass:"lowpass usage: (x, input, cutoff)",highpass:"highpass usage: (x, input, cutoff)",segment:"segment usage: (x, ...pairs)",at:"at usage: (d, f, x)"},math:{abs:"Returns the absolute value of x.",acos:"Returns the arccosine of x.",acosh:"Returns the hyperbolic arccosine of x.",asin:"Returns the arcsine of x.",asinh:"Returns the hyperbolic arcsine of a number.",atan:"Returns the arctangent of x.",atanh:"Returns the hyperbolic arctangent of x.",atan2:"Returns the arctangent of the quotient of its arguments.",cbrt:"Returns the cube root of x.",ceil:"Returns the smallest integer greater than or equal to x.",clz32:"Returns the number of leading zero bits of the 32-bit integer x.",cos:"Returns the cosine of x.",cosh:"Returns the hyperbolic cosine of x.",exp:"Returns ex, where x is the argument, and e is Euler's constant (2.718\u2026, the base of the natural logarithm).",expm1:"Returns subtracting 1 from exp(x).",floor:"Returns the largest integer less than or equal to x.",fround:"Returns the nearest single precision float representation of x.",hypot:"Returns the square root of the sum of squares of its arguments.",imul:"Returns the result of the 32-bit integer multiplication of x and y.",log:"Returns the natural logarithm (\u33D2e; also, \u33D1) of x.",log1p:"Returns the natural logarithm (\u33D2e; also \u33D1) of 1 + x for the number x.",log10:"Returns the base-10 logarithm of x.",log2:"Returns the base-2 logarithm of x.",max:"Returns the largest of zero or more numbers.",min:"Returns the smallest of zero or more numbers.",pow:"Returns base x to the exponent power y (that is, xy).",random:"Returns a pseudo-random number between 0 and 1.",round:"Returns the value of the number x rounded to the nearest integer.",sign:"Returns the sign of the x, indicating whether x is positive, negative, or zero.",sin:"Returns the sine of x.",sinh:"Returns the hyperbolic sine of x.",sqrt:"Returns the positive square root of x.",tan:"Returns the tangent of x.",tanh:"Returns the hyperbolic tangent of x.",trunc:"Returns the integer portion of x, removing any fractional digits."},constant:{e:"Euler's constant and the base of natural logarithms; approximately 2.718.",ln2:"Natural logarithm of 2; approximately 0.693.",ln10:"Natural logarithm of 10; approximately 2.303.",log2e:"Base-2 logarithm of E; approximately 1.443.",log10e:"Base-10 logarithm of E; approximately 0.434.",pi:"Ratio of a circle's circumference to its diameter; approximately 3.14159.",sqrt1_2:"Square root of \xBD; approximately 0.707.",sqrt2:"Square root of 2; approximately 1.414."},util:{lerp:"lerp usage: (x, y, a)",clamp:"clamp usage: (x, min, max)"},graphit:{"@size":"Plot each pixel","@adaptative":"Adaptative plot","@auto":"Better adaptative plot","@fft":"FFT of the sound","@!":"Precision","@/dot":"Dot plot mode","@/point":"Point plot mode","@/line":"Line plot mode","@ ":"@ x0 -> x1 : Plot range [x0;x1]"}};const G=t=>t&t-1?2**(Math.log2(t)+1|0):t,V={linear:"x","linear-horizontal":"y",polar:"o",parametric:"t",sound:"t",fft:"t"};self.lerp=(t,e,s)=>t+(e-t)*s,self.clamp=(t,e,s)=>Math.min(Math.max(t,e),s);for(let t of Array.from(Object.getOwnPropertyNames(Math)))self[t.toLowerCase()]=self[t]=Math[t];const I=self.PI,j=self.tau=self.TAU=I*2;self.eta=self.ETA=I/2,self.ln=self.log,self.osc=(t,e,s="sine",r=.5)=>{const a=++self._state.call;if(self._state.n<0)return 0;self._state.fs[a]||(self._state.fs[a]={f:0,last_x:0});const i=self._state.fs[a],n=t-i.last_x;i.last_x=t;const o=i.f+=self.clamp(e,0,22050)*n;switch(s){case"sine":return Math.sin(o*j);case"square":return Math.sign(Math.sin(o*j));case"smoothsquare":return Math.tanh(Math.sin(o*j)/r);case"sawtooth":return o%1*2-1;case"triangle":return Math.abs(o%1*4-2)-1;case"noise":return Math.random()*2-1;default:throw new Error(`Unknown oscillator type: ${s}`)}},self.sine=(t,e)=>self.osc(t,e,"sine"),self.square=(t,e)=>self.osc(t,e,"square"),self.smoothsquare=(t,e,s=.5)=>self.osc(t,e,"smoothsquare",s),self.sawtooth=(t,e)=>self.osc(t,e,"sawtooth"),self.triangle=(t,e)=>self.osc(t,e,"triangle"),self.noise=()=>self.osc(0,0,"noise"),self.oscs=(t,e,s,r=.5)=>{let a=0;e=Array.isArray(e)?e:[e];for(let i=0;i<e.length;i++)a+=self.osc(t,e[i],s,r);return a/e.length},self.adsr=(t,e=.2,s=.1,r=.4,a=.3,i=.5,n=null)=>(n=n||self._state.max,t=t/n,t<0?0:t<=e?t/e:t<=e+s?1-(1-i)*(t-e)/s:t<=e+s+r?i:t<=e+s+r+a?i-(i-0)*(t-e-s-r)/a:0),self.iirFilterGen=t=>(e,s,r)=>{const a=++self._state.call;if(self._state.n<0)return 0;if(!self._state.fs[a]){const[f,u]=t(s,r);self._state.fs[a]={a:f,b:u,x:new Array(f.length).fill(0),y:new Array(u.length).fill(0)}}const i=self._state.fs[a],{a:n,b:o,x:l,y:c}=i;let h=0;for(let f=0;f<n.length;f++)h+=n[f]*l[f];for(let f=0;f<o.length;f++)h+=o[f]*c[f];for(let f=n.length-1;f>0;f--)l[f]=l[f-1];for(let f=o.length-1;f>0;f--)c[f]=c[f-1];return l[0]=e,c[0]=h,h},self.lowpass=self.iirFilterGen(t=>{const e=t*self._state.step,s=Math.exp(-j*e);return[[1-s],[s]]}),self.lowpass4=self.iirFilterGen(t=>{const s=t*self._state.step,r=Math.exp(-14.445*s);return[[Math.pow(1-r,4)],[4*r,-6*Math.pow(r,2),4*Math.pow(r,3),-Math.pow(r,4)]]}),self.highpass=self.iirFilterGen(t=>{const e=t*self._state.step,s=Math.exp(-j*e);return[[(1+s)/2,-(1+s)/2],[s]]}),self.bandpass=self.iirFilterGen((t,e)=>{const s=t*self._state.step,r=e*self._state.step,a=2*Math.cos(j*s),i=1-3*r,n=(1-i*a+i*i)/(2-a);return[[1-n,(n-i)*a,i*i-n],[i*a,-i*i]]}),self.bandreject=self.iirFilterGen((t,e)=>{const s=t*self._state.step,r=e*self._state.step,a=2*Math.cos(j*s),i=1-3*r,n=(1-i*a+i*i)/(2-a);return[[n,-n*a,n],[i*a,-i*i]]}),self.pulse=()=>{const t=++self._state.call;return self._state.n<0||self._state.fs[t]?0:(self._state.fs[t]=!0,1)},self.peak=(t,e,s=1)=>{const r=++self._state.call;return t>=e&&!self._state.fs[r]?(self._state.fs[r]=!0,s):0},self.band=(t,e,s,r=1)=>t>e&&t<s?r:0,self.normalize=(t,e=1/0,s=!0)=>{const r=++self._state.call,a=self._state.rfs[r];if(self._state.processing){if(self._state.processing===r){let i=0,n=0,o=1;for(let l=0;l<a.inputs.length;l++){const c=Math.abs(a.inputs[l]);c<1&&(n=n+(c-n)/o++),i<c&&c<e&&(i=c)}a.amax=i,a.aavg=n}return}if(a){if(a.amax)return t/((s?a.aavg:1)*a.amax)}else return self._state.rfs[r]={inputs:[t]},self._state.toPostProcess.push(r),0;return a.inputs[self._state.i]=t,0},self.fft=t=>{const e=++self._state.call,s=self._state.rfs[e];if(self._state.processing){if(self._state.processing===e){const r=G(s.inputs.length),a=new Float32Array(r),i=new Float32Array(r);for(let o=0;o<r;o++)a[o]=o<s.inputs.length?s.inputs[o]:0,i[o]=0;self._fft(a,i),s.outputs=[];const n=2/r;for(let o=0;o<s.inputs.length;o++){const l=~~(r/2*(o/s.inputs.length));s.outputs[o]=n*Math.sqrt(a[l]**2+i[l]**2)}}return}if(s){if(s.outputs)return s.outputs[self._state.i]}else return self._state.rfs[e]={inputs:[t]},self._state.toPostProcess.push(e),0;return s.inputs[self._state.i]=t,0},self.ifft=t=>{const e=++self._state.call,s=self._state.rfs[e];if(self._state.processing){if(self._state.processing===e){const r=G(s.inputs.length),a=new Float32Array(r),i=new Float32Array(r);for(let n=0;n<r;n++)a[n]=0,i[n]=n<s.inputs.length?s.inputs[n]:0;self._fft(a,i),s.outputs=[];for(let n=0;n<s.inputs.length;n++){const o=~~(r/2*(n/s.inputs.length));s.outputs[n]=i[o]}}return}if(s){if(s.outputs)return s.outputs[self._state.i]}else return self._state.rfs[e]={inputs:[t]},self._state.toPostProcess.push(e),0;return s.inputs[self._state.i]=t,0},self._fft=(t,e)=>{const s=t.length;if(s!==e.length)throw new Error("Mismatched lengths");const r=Math.log2(s);if(r!==~~r)throw new Error("Length is not a power of 2");const a=new Float32Array(s/2),i=new Float32Array(s/2);for(var n=0;n<s/2;n++)a[n]=Math.cos(j*n/s),i[n]=Math.sin(j*n/s);for(let o=0;o<s;o++){let l=0,c=o;for(let h=0;h<r;h++)l=l<<1|c&1,c>>>=1;l>o&&([t[o],t[l]]=[t[l],t[o]],[e[o],e[l]]=[e[l],e[o]])}for(let o=2;o<=s;o*=2){const l=o/2,c=s/o;for(let h=0;h<s;h+=o)for(let f=h,u=0;f<h+l;f++,u+=c){const N=t[f+l]*a[u]+e[f+l]*i[u],g=-t[f+l]*i[u]+e[f+l]*a[u];t[f+l]=t[f]-N,e[f+l]=e[f]-g,t[f]+=N,e[f]+=g}}return[t,e]},self.segment=(t,...e)=>{for(let s=0;s<e.length;s+=2)if(t<e[s])return e[s+1]},self.at=(t,e,s)=>e(s+t),self.__doc__=Object.fromEntries(Object.entries(D).map(([t,e])=>Object.entries(e).map(([s,r])=>[self[s],`${t}: ${r}`])).flat());const z={epsilon:1e-9,sampling:1500,subsampling:32,minBlockSize:10,precisionPass:8,precision:I/1024,extremumPass:32,straightness:1e-5,maxPoints:1e4,overflow:.1},L=(t,e,s,r,a)=>{var i,n;if(isNaN(e)||isNaN(s)||e<r[0][0]||e>r[0][1]||s<r[1][0]||s>r[1][1]){(i=t.out)!=null&&i.length||t.length>0&&t.push(e,s),t.out=[e,s];return}(n=t.out)!=null&&n.length&&(a==="linear-horizontal"?t.push(NaN,((t[t.length-1]||r[1][0])+t.out[1])/2):a==="linear"?t.push(((t[t.length-2]||r[0][0])+t.out[0])/2,NaN):t.push(NaN,NaN),t.push(...t.out),t.out.splice(0)),t.push(e,s)},X=(t,e,s,r,a,i,n,o)=>{if(s==="linear"){const l=o*r+(1-o)*i,c=e[0](l);t(l,c)}else if(s==="linear-horizontal"){const l=o*a+(1-o)*n,c=e[0](l);t(c,l)}},U=(t,e,s,r,a)=>{const[[i,n],[o,l]]=r,c=[],h=(g,w)=>L(c,g,w,r,s),f=(g,w,M,m,p)=>X(h,e,s,g,w,M,m,p),u=(l-o)/(n-i);let N=0;for(let g=0;g+N<t.length;g+=4){const w=t[g],M=t[g+1],m=t[g+2+N],p=t[g+3+N],x=t[g+4+N],_=t[g+5+N];if(s==="linear"&&(isNaN(M)||isNaN(p)||isNaN(_))||s==="linear-horizontal"&&(isNaN(w)||isNaN(m)||isNaN(x))){g+=N,N=0,h(w,M),h(m,p);continue}const R=Math.atan2(p-M,u*(m-w)),F=Math.atan2(_-p,u*(x-m))-R,y=Math.abs(F),b=((x-w)/(n-i))**2+((_-M)/(l-o))**2;if(y*b<z.straightness){g-=4,N+=2;continue}if(N&&(g+=N,N=0),a){h(w,M),h(m,p);continue}const d=y>z.precision;h(w,M),d&&f(w,M,m,p,1/2),h(m,p),d&&f(m,p,x,_,1/2)}return c},H=(t,e,s,r)=>{for(let a=2;a<t.length-2;a+=2){let i=t[a-2],n=t[a-1],o=t[a],l=t[a+1],c=t[a+2],h=t[a+3];const f=r[s==="linear-horizontal"?0:1];if(s==="linear-horizontal"&&([i,n]=[n,i],[o,l]=[l,o],[c,h]=[h,c]),isNaN(l)||isNaN(h)||isNaN(n))continue;const u=Math.sign(l-n),N=Math.sign(h-l);if(u!==N){let g=i,w=o,M=c,m=l;for(let p=0;p<z.extremumPass;p++){const x=(g+w)/2,_=e[0](x),R=(w+M)/2,v=e[0](R);if(Math.sign(_-m)===u?(M=w,w=x,m=_):Math.sign(v-m)===u?(g=w,w=R,m=v):(g=x,M=R),g===M||m>f[1]||m<f[0])break}t[a]=w,t[a+1]=m,s==="linear-horizontal"&&([t[a],t[a+1]]=[t[a+1],t[a]])}}},J=(t,e,s,r,a,i)=>{let n=[];const o=(a-r)/i;for(let l=0;l<i;l++){const c=r+l*o,[h,f]=q(t,e,c);L(n,h,f,s,e)}n=U(n,t,e,s,!0),H(n,t,e,s);for(let l=0;l<z.precisionPass&&!(n.length>z.maxPoints);l++)n=U(n,t,e,s);return n},Q=(t,e,s,r,a,i)=>{const n=a-r;r-=n*z.overflow/2,a+=n*z.overflow/2;const o=[];let l=[NaN,NaN],c=[NaN,NaN],h=q(t,e,r);const[f,u]=e==="linear-horizontal"?[1,0]:[0,1],N=s[e==="linear-horizontal"?0:1],g=s[e==="linear-horizontal"?1:0],w=(N[1]-N[0])/(g[1]-g[0]),M=(g[1]-g[0])*z.epsilon;let m=null,p={min:[],max:[]},x=!1;const _=(a-r)/i;for(let R=0;R<i;R++){const v=r+R*_;if(c=l,l=h,h=q(t,e,v+_),isNaN(l[u])||isNaN(h[u])){o.push(l[0],l[1]);continue}if(!isNaN(c[u])&&!m&&v<a-_){const P=Math.atan2(l[u]-c[u],w*(l[f]-c[f])),k=Math.atan2(h[u]-l[u],w*(h[f]-l[f]))-P,E=Math.abs(k),T=((h[f]-c[f])/(g[1]-g[0]))**2+((h[u]-c[u])/(N[1]-N[0]))**2;if(E*T<z.straightness){x=!0,l=c;continue}else x&&(x=!1,R--,h=l,l=c)}m||o.push(l[0],l[1]);let F=l[f],y=h[f],b=q(t,e,F+(y-F)/3),d=q(t,e,y-(y-F)/3);const tt=Math.sign(b[u]-l[u]),C=Math.sign(d[u]-b[u]),$=Math.sign(h[u]-d[u]),O=$===-1?"max":"min";if(tt!==C||C!==$)for(let P=0;P<z.extremumPass;P++){if(b[u]>N[1]&&d[u]<N[0]||b[u]<N[0]&&d[u]>N[1]){const A=q(t,e,(F+y)/2),k=Math.sign(A[u]-b[u]),E=Math.sign(d[u]-A[u]);if(k!==E){b[u]>d[u]?(p.max.push(b),p.min.push(d)):(p.max.push(d),p.min.push(b)),m?b[u]>d[u]?(m.max.push(b[0],b[1]),m.min.push(d[0],d[1])):(m.max.push(d[0],d[1]),m.min.push(b[0],b[1])):(o.push(b[0],b[1]),e==="linear-horizontal"?o.push(NaN,(b[1]+d[1])/2):o.push((b[0]+d[0])/2,NaN),o.push(d[0],d[1]));break}}if($===-1?b[u]<d[u]?F=b[f]:y=d[f]:b[u]>d[u]?F=b[f]:y=d[f],Math.abs(y-F)<M||P===z.extremumPass-1){$===-1&&b[u]>d[u]||$===1&&b[u]<d[u]?(p[O].push(b),m?m[O].push(b[0],b[1]):o.push(b[0],b[1])):(p[O].push(d),m?m[O].push(d[0],d[1]):o.push(d[0],d[1]));break}b=q(t,e,F+(y-F)/3),d=q(t,e,y-(y-F)/3)}else if(p.max.length+p.min.length>0){let P=null,A=0,k=!1;for(let E=0;E<=z.subsampling;E++){let T=E===0?l:E===z.subsampling?h:q(t,e,((z.subsampling-E)*l[f]+E*h[f])/z.subsampling);if(P){const S=Math.sign(T[u]-P[u]);if(A&&S!==A){p[S===-1?"max":"min"].push(T),k=!0;break}A=S}P=T}k||(p.min.shift(),p.max.shift())}else p.min.shift(),p.max.shift();if(p.min.length>3&&p.min.shift(),p.max.length>3&&p.max.shift(),m){if(p.min.length<1&&p.max.length<1||R===i-1){if(m.min.length>2&&m.max.length>2){o.push(NaN,NaN);for(let P=0;P<m.min.length;P+=2)o.push(m.min[P],m.min[P+1]);e==="linear-horizontal"?(o.push(m.min[m.min.length-2],l[1]),o.push(m.max[m.max.length-2],l[1])):(o.push(l[0],m.min[m.min.length-1]),o.push(l[0],m.max[m.max.length-1]));for(let P=m.max.length-2;P>=0;P-=2)o.push(m.max[P],m.max[P+1]);o.push(NaN,NaN)}o.push(l[0],l[1]),m=null}}else if(p.min.length>=1&&p.max.length>=1){const P=p.min[p.min.length-1],A=p.max[p.max.length-1],k=Math.min(P[f],A[f]);m={min:e==="linear-horizontal"?[P[u],k]:[k,P[u]],max:e==="linear-horizontal"?[A[u],k]:[k,A[u]]}}}return o.push(h[0],h[1]),o},W=(t,e,s,r,a,i)=>{const n=[],o=(a-r)/i;for(let l=0;l<i;l++){const c=r+l*o,[h,f]=q(t,e,c);n.push(h,f)}return n},Z=(t,e,s,r,a,i)=>{const n=G(i),o=[],l=new Float32Array(n),c=new Float32Array(n),h=(a-r)/n;for(let g=0;g<n;g++){const[,w]=q(t,e,r+g*h);l[g]=w,c[g]=0}self._fft(l,c);const f=2/n,u=n*h,N=Math.max(1,~~(n/s[0][2]));for(let g=0;g<n/2;g++){let w=g,M=0;for(;g-w<N;g++)M=Math.max(M,f*Math.sqrt(l[g]**2+c[g]**2));o.push(u*(w+g+1)/2,M)}return o},K=(t,e,s,r,a,i)=>{const n=G(i),o=[],l=new Float32Array(n),c=new Float32Array(n),h=(a-r)/n;for(let f=0;f<n;f++){const[,u]=q(t,e,r+f*h);l[f]=0,c[f]=u}self._fft(l,c);for(let f=0;f*h<a&&f<l.length;f++)o.push(f*h,l[f]);return o},q=(t,e,s)=>{if(self._state.call=0,self._state.n=s,self._state.i++,e==="parametric"){const r=t[0](s),a=t[1](s);return[r,a]}else if(e==="polar"){const r=t[0](s);return[r*Math.cos(s),r*Math.sin(s)]}else{if(e==="linear-horizontal")return[t[0](s),s];{const r=t[0](s);return[s,r]}}},Y=["line","dot","point"],B={};onmessage=({data:{index:t,region:e,affects:s,funs:r,type:a,min:i,max:n,samples:o,mode:l,rendering:c,recs:h,job:f,uuid:u}})=>{let N="",g=[],w,M;try{if(a==="unknown")throw new Error(`Invalid function type ${r.join(", ")}`);if(!Y.includes(l))throw new Error(`Invalid mode: ${l}, must be one of ${Y.join(", ")}`);if(typeof i=="string"&&(i=new Function("return "+i)()),typeof n=="string"&&(n=new Function("return "+n)()),typeof o=="string"&&(o=new Function("return "+o)()),isNaN(o)||o===0)throw new Error(`Invalid sample size ${o}`);c||(["linear","linear-horizontal"].includes(a)?c="auto":c="size");for(let x=0;x<s.length;x++){const[_,R]=s[x],v=new Function("","return "+R)();B[_]=self[_],self[_]=v}h&&Object.entries(h).forEach(([x,_])=>{!_||(self[`$rec${x}`]=R=>{const v=~~Math.round(R*_.sampleRate);return v>=0&&v<_.buffer.length?_.buffer[v]:0})}),self._state={call:0,i:-1,fs:[],rfs:[],min:i,max:n,samples:o,step:(n-i)/o,toPostProcess:[],processing:null};let m="";a==="sound"&&(m=`let f = t * ${o/(2*n*n)};`);const p=r.map(x=>new Function(V[a],m+"return "+x));if(f==="check"){self._state.call=self._state.n=0;const x=p[0](Math.random()*(n-i)+i);if(typeof x!="number"){let _;throw typeof x=="function"?_=new Error(self.__doc__[x]||"Function not supported"):typeof x>"u"?_=new Error(`${r[0]} is undefined`):_=new Error(`${typeof x} is not a number`),_}a==="sound"?c==="fft"?w=[[0,o/n/2,e[0][2]],[0,1,e[1][2]]]:w=[[0,n,e[0][2]],[-1,1,e[1][2]]]:w=[[-2,2,e[0][2]],[-2*e[1][2]/e[0][2],2*e[1][2]/e[0][2],e[1][2]]]}else if(f==="sound"){M=new Float32Array(o);let x=0;if(c==="ifft"){g=K(p,a,e,i,n,o);for(let _=1;_<g.length;_+=2)M[x++]=g[_]}else do{self._state.toPostProcess.length&&(self._state.processing=self._state.toPostProcess.shift(),q(p,a,0),self._state.processing=null,self._state.i=-1,self._state.fs=[],x=0);const _=(n-i)/o;for(let R=0;R<o;R++){const v=i+R*_;self._state.call=0,self._state.n=v,self._state.i++,M[x++]=p[0](v)}}while(self._state.toPostProcess.length)}else{do self._state.toPostProcess.length&&(self._state.processing=self._state.toPostProcess.shift(),q(p,a,0),self._state.processing=null,self._state.i=-1,self._state.fs=[]),c==="size"?g=W(p,a,e,i,n,o):c==="adaptative"?g=J(p,a,e,i,n,o):c==="auto"?g=Q(p,a,e,i,n,o):c==="fft"?g=Z(p,a,e,i,n,o):c==="ifft"&&(g=K(p,a,e,i,n,o));while(self._state.toPostProcess.length);M=new Float32Array(g)}h&&Object.keys(h).forEach(x=>{delete self[`$rec${x}`]});for(let x=0;x<s.length;x++){const[_]=s[x];self[_]=B[_],delete B[_]}}catch(m){N=m}postMessage({index:t,values:M,type:a,mode:l,max:n,samples:o,rendering:c,preferredRegion:w,err:N,uuid:u},M==null?void 0:M.buffer)}})();

(function(){"use strict";var S={sound:{adsr:"adsr usage: (x, attack = 0.2, decay = 0.1, sustain = 0.4, release = 0.3, sustainLevel = 0.5)",osc:"osc usage: (freq, x, type = sine|square|smoothsquare|sawtooth|triangle, e = 0.01)",oscs:"oscs usage: (freqs, x, type = sine|square|smoothsquare|sawtooth|triangle, e = 0.01)",sine:"sine usage: (freq, x)",square:"square usage: (freq, x)",smoothsquare:"smoothsquare usage: (freq, x, e = 0.01)",sawtooth:"sawtooth usage: (freq, x)",triangle:"triangle usage: (freq, x)",lowpass:"lowpass usage: (x, cutoff)",highpass:"highpass usage: (x, cutoff)",segment:"segment usage: (x, ...pairs)",at:"at usage: (d, f, x)"},math:{abs:"Returns the absolute value of x.",acos:"Returns the arccosine of x.",acosh:"Returns the hyperbolic arccosine of x.",asin:"Returns the arcsine of x.",asinh:"Returns the hyperbolic arcsine of a number.",atan:"Returns the arctangent of x.",atanh:"Returns the hyperbolic arctangent of x.",atan2:"Returns the arctangent of the quotient of its arguments.",cbrt:"Returns the cube root of x.",ceil:"Returns the smallest integer greater than or equal to x.",clz32:"Returns the number of leading zero bits of the 32-bit integer x.",cos:"Returns the cosine of x.",cosh:"Returns the hyperbolic cosine of x.",exp:"Returns ex, where x is the argument, and e is Euler's constant (2.718\u2026, the base of the natural logarithm).",expm1:"Returns subtracting 1 from exp(x).",floor:"Returns the largest integer less than or equal to x.",fround:"Returns the nearest single precision float representation of x.",hypot:"Returns the square root of the sum of squares of its arguments.",imul:"Returns the result of the 32-bit integer multiplication of x and y.",log:"Returns the natural logarithm (\u33D2e; also, \u33D1) of x.",log1p:"Returns the natural logarithm (\u33D2e; also \u33D1) of 1 + x for the number x.",log10:"Returns the base-10 logarithm of x.",log2:"Returns the base-2 logarithm of x.",max:"Returns the largest of zero or more numbers.",min:"Returns the smallest of zero or more numbers.",pow:"Returns base x to the exponent power y (that is, xy).",random:"Returns a pseudo-random number between 0 and 1.",round:"Returns the value of the number x rounded to the nearest integer.",sign:"Returns the sign of the x, indicating whether x is positive, negative, or zero.",sin:"Returns the sine of x.",sinh:"Returns the hyperbolic sine of x.",sqrt:"Returns the positive square root of x.",tan:"Returns the tangent of x.",tanh:"Returns the hyperbolic tangent of x.",trunc:"Returns the integer portion of x, removing any fractional digits."},constant:{e:"Euler's constant and the base of natural logarithms; approximately 2.718.",ln2:"Natural logarithm of 2; approximately 0.693.",ln10:"Natural logarithm of 10; approximately 2.303.",log2e:"Base-2 logarithm of E; approximately 1.443.",log10e:"Base-10 logarithm of E; approximately 0.434.",pi:"Ratio of a circle's circumference to its diameter; approximately 3.14159.",sqrt1_2:"Square root of \xBD; approximately 0.707.",sqrt2:"Square root of 2; approximately 1.414."},graphit:{"@size":"Plot each pixel","@adaptative":"Adaptative plot","@auto":"Better adaptative plot","@!":"Precision","@/dot":"Dot plot mode","@/point":"Point plot mode","@/line":"Line plot mode","@ ":"@ x0 -> x1 : Plot range [x0;x1]"}};const Y={linear:"x","linear-horizontal":"y",polar:"o",parametric:"t"};for(let e of Array.from(Object.getOwnPropertyNames(Math)))self[e.toLowerCase()]=self[e]=Math[e];const F=self.PI;self.tau=self.TAU=F*2,self.eta=self.ETA=F/2,self.ln=self.log,self.osc=(e,t,s="sine",a=.01)=>e<0?0:s==="sine"?Math.sin(2*Math.PI*t*e):s==="square"?Math.sign(Math.sin(2*Math.PI*t*e)):s==="smoothsquare"?Math.sin(2*Math.PI*t*e)/Math.sqrt(Math.sin(2*Math.PI*t*e)**2+a):s==="sawtooth"?2*(e*t-~~(e*t+.5)):s==="triangle"?2*Math.abs(2*(e*t+.25-~~(e*t+.75)))-1:0,self.sine=(e,t)=>self.osc(e,t,"sine"),self.square=(e,t)=>self.osc(e,t,"square"),self.smoothsquare=(e,t,s=.01)=>self.osc(e,t,"smoothsquare",s),self.sawtooth=(e,t)=>self.osc(e,t,"sawtooth"),self.triangle=(e,t)=>self.osc(e,t,"triangle"),self.oscs=(e,t,s,a)=>{let o=0;e=Array.isArray(e)?e:[e];for(let f=0;f<e.length;f++)o+=self.osc(e[f],t,s,a);return o/e.length},self.adsr=(e,t=.2,s=.1,a=.4,o=.3,f=.5)=>e<0?0:e<=t?e/t:e<=t+s?1-(1-f)*(e-t)/s:e<=t+s+a?f:e<=t+s+a+o?f-(f-0)*(e-t-s-a)/o:0,self.lowpass=(e,t)=>{const s=`lowpass_${t}`;if(!self._state[s]){const a=1/(2*Math.PI*t),o=1/self._state.sampleRate;self._state[s]={alpha:o/(a+o),last_y:0}}return self._state[s].last_y=self._state[s].last_y+self._state[s].alpha*(e-self._state[s].last_y)},self.highpass=(e,t)=>{const s=`highpass_${t}`;if(!self._state[s]){const a=1/(2*Math.PI*t),o=1/self._state.sampleRate;self._state[s]={alpha:a/(a+o),last_x:0,last_y:0}}return self._state[s].last_y=self._state[s].alpha*(self._state[s].last_y+e-self._state[s].last_x),self._state[s].last_x=e,self._state[s].last_y},self.segment=(e,...t)=>{for(let s=0;s<t.length;s+=2)if(e<t[s])return t[s+1]},self.at=(e,t,s)=>t(s+e),self.__doc__=Object.fromEntries(Object.entries(S).map(([e,t])=>Object.entries(t).map(([s,a])=>[self[s],`${e}: ${a}`])).flat());const v={epsilon:1e-9,sampling:1500,subsampling:32,minBlockSize:10,precisionPass:8,precision:F/1024,extremumPass:32,straightness:1e-5,maxPoints:1e4,overflow:.1},O=(e,t,s,a,o)=>{var f,g;if(isNaN(t)||isNaN(s)||t<a[0][0]||t>a[0][1]||s<a[1][0]||s>a[1][1]){(f=e.out)!=null&&f.length||e.length>0&&e.push(t,s),e.out=[t,s];return}(g=e.out)!=null&&g.length&&(o==="linear-horizontal"?e.push(NaN,((e[e.length-1]||a[1][0])+e.out[1])/2):o==="linear"?e.push(((e[e.length-2]||a[0][0])+e.out[0])/2,NaN):e.push(NaN,NaN),e.push(...e.out),e.out.splice(0)),e.push(t,s)},C=(e,t,s,a,o,f,g,r)=>{if(s==="linear"){const l=r*a+(1-r)*f,N=t[0](l);e(l,N)}else if(s==="linear-horizontal"){const l=r*o+(1-r)*g,N=t[0](l);e(N,l)}},L=(e,t,s,a,o)=>{const[[f,g],[r,l]]=a,N=[],u=(b,p)=>O(N,b,p,a,s),R=(b,p,P,n,h)=>C(u,t,s,b,p,P,n,h),i=(l-r)/(g-f);let M=0;for(let b=0;b+M<e.length;b+=4){const p=e[b],P=e[b+1],n=e[b+2+M],h=e[b+3+M],d=e[b+4+M],m=e[b+5+M];if(s==="linear"&&(isNaN(P)||isNaN(h)||isNaN(m))||s==="linear-horizontal"&&(isNaN(p)||isNaN(n)||isNaN(d))){b+=M,M=0,u(p,P),u(n,h);continue}const w=Math.atan2(h-P,i*(n-p)),x=Math.atan2(m-h,i*(d-n))-w,c=Math.abs(x),B=((d-p)/(g-f))**2+((m-P)/(l-r))**2;if(c*B<v.straightness){b-=4,M+=2;continue}if(M&&(b+=M,M=0),o){u(p,P),u(n,h);continue}const A=c>v.precision;u(p,P),A&&R(p,P,n,h,1/2),u(n,h),A&&R(n,h,d,m,1/2)}return N},D=(e,t,s,a)=>{for(let o=2;o<e.length-2;o+=2){let f=e[o-2],g=e[o-1],r=e[o],l=e[o+1],N=e[o+2],u=e[o+3];const R=a[s==="linear-horizontal"?0:1];if(s==="linear-horizontal"&&([f,g]=[g,f],[r,l]=[l,r],[N,u]=[u,N]),isNaN(l)||isNaN(u)||isNaN(g))continue;const i=Math.sign(l-g),M=Math.sign(u-l);if(i!==M){let b=f,p=r,P=N,n=l;for(let h=0;h<v.extremumPass;h++){const d=(b+p)/2,m=t[0](d),w=(p+P)/2,_=t[0](w);if(Math.sign(m-n)===i?(P=p,p=d,n=m):Math.sign(_-n)===i?(b=p,p=w,n=_):(b=d,P=w),b===P||n>R[1]||n<R[0])break}e[o]=p,e[o+1]=n,s==="linear-horizontal"&&([e[o],e[o+1]]=[e[o+1],e[o]])}}},V=(e,t,s,a,o,f)=>{let g=[];for(let r=a;r<o;r+=f){const[l,N]=y(e,t,r);O(g,l,N,s,t)}g=L(g,e,t,s,!0),D(g,e,t,s);for(let r=0;r<v.precisionPass&&!(g.length>v.maxPoints);r++)g=L(g,e,t,s);return g},X=(e,t,s,a,o,f)=>{const g=o-a;a-=g*v.overflow/2,o+=g*v.overflow/2;const r=[];let l=[NaN,NaN],N=[NaN,NaN],u=y(e,t,a);const[R,i]=t==="linear-horizontal"?[1,0]:[0,1],M=s[t==="linear-horizontal"?0:1],b=s[t==="linear-horizontal"?1:0],p=(M[1]-M[0])/(b[1]-b[0]),P=(b[1]-b[0])*v.epsilon;let n=null,h={min:[],max:[]},d=!1;for(let m=a;m<=o;m+=f){if(N=l,l=u,u=y(e,t,m+f),isNaN(l[i])||isNaN(u[i])){r.push(l[0],l[1]);continue}if(!isNaN(N[i])&&!n&&m<o-f){const z=Math.atan2(l[i]-N[i],p*(l[R]-N[R])),E=Math.atan2(u[i]-l[i],p*(u[R]-l[R]))-z,$=Math.abs(E),j=((u[R]-N[R])/(b[1]-b[0]))**2+((u[i]-N[i])/(M[1]-M[0]))**2;if($*j<v.straightness){d=!0,l=N;continue}else d&&(d=!1,m-=f,u=l,l=N)}n||r.push(l[0],l[1]);let w=l[R],_=u[R],x=y(e,t,w+(_-w)/3),c=y(e,t,_-(_-w)/3);const B=Math.sign(x[i]-l[i]),A=Math.sign(c[i]-x[i]),I=Math.sign(u[i]-c[i]),k=I===-1?"max":"min";if(B!==A||A!==I)for(let z=0;z<v.extremumPass;z++){if(x[i]>M[1]&&c[i]<M[0]||x[i]<M[0]&&c[i]>M[1]){const q=y(e,t,(w+_)/2),E=Math.sign(q[i]-x[i]),$=Math.sign(c[i]-q[i]);if(E!==$){x[i]>c[i]?(h.max.push(x),h.min.push(c)):(h.max.push(c),h.min.push(x)),n?x[i]>c[i]?(n.max.push(x[0],x[1]),n.min.push(c[0],c[1])):(n.max.push(c[0],c[1]),n.min.push(x[0],x[1])):(r.push(x[0],x[1]),t==="linear-horizontal"?r.push(NaN,(x[1]+c[1])/2):r.push((x[0]+c[0])/2,NaN),r.push(c[0],c[1]));break}}if(I===-1?x[i]<c[i]?w=x[R]:_=c[R]:x[i]>c[i]?w=x[R]:_=c[R],Math.abs(_-w)<P||z===v.extremumPass-1){I===-1&&x[i]>c[i]||I===1&&x[i]<c[i]?(h[k].push(x),n?n[k].push(x[0],x[1]):r.push(x[0],x[1])):(h[k].push(c),n?n[k].push(c[0],c[1]):r.push(c[0],c[1]));break}x=y(e,t,w+(_-w)/3),c=y(e,t,_-(_-w)/3)}else if(h.max.length+h.min.length>0){let z=null,q=0,E=!1;for(let $=0;$<=v.subsampling;$++){let j=$===0?l:$===v.subsampling?u:y(e,t,((v.subsampling-$)*l[R]+$*u[R])/v.subsampling);if(z){const G=Math.sign(j[i]-z[i]);if(q&&G!==q){h[G===-1?"max":"min"].push(j),E=!0;break}q=G}z=j}E||(h.min.shift(),h.max.shift())}else h.min.shift(),h.max.shift();if(h.min.length>3&&h.min.shift(),h.max.length>3&&h.max.shift(),n){if(h.min.length<1&&h.max.length<1||m>o-f){if(n.min.length>2&&n.max.length>2){r.push(NaN,NaN);for(let z=0;z<n.min.length;z+=2)r.push(n.min[z],n.min[z+1]);t==="linear-horizontal"?(r.push(n.min[n.min.length-2],l[1]),r.push(n.max[n.max.length-2],l[1])):(r.push(l[0],n.min[n.min.length-1]),r.push(l[0],n.max[n.max.length-1]));for(let z=n.max.length-2;z>=0;z-=2)r.push(n.max[z],n.max[z+1]);r.push(NaN,NaN)}r.push(l[0],l[1]),n=null}}else if(h.min.length>=1&&h.max.length>=1){const z=h.min[h.min.length-1],q=h.max[h.max.length-1],E=Math.min(z[R],q[R]);n={min:t==="linear-horizontal"?[z[i],E]:[E,z[i]],max:t==="linear-horizontal"?[q[i],E]:[E,q[i]]}}}return r.push(u[0],u[1]),r},H=(e,t,s,a,o,f)=>{const g=[];for(let r=a;r<o;r+=f){const[l,N]=y(e,t,r);O(g,l,N,s,t)}return g},y=(e,t,s)=>{if(t==="parametric"){const a=e[0](s),o=e[1](s);return[a,o]}else if(t==="polar"){const a=e[0](s);return[a*Math.cos(s),a*Math.sin(s)]}else{if(t==="linear-horizontal")return[e[0](s),s];if(t==="linear"){const a=e[0](s);return[s,a]}}throw new Error(`Unknown plot type ${t}`)},U=["line","dot","point"],T={};onmessage=({data:{index:e,funs:t,type:s,min:a,max:o,samples:f,region:g,affects:r,mode:l,rendering:N,recs:u,dimensions:R=2,sampleRate:i,uuid:M}})=>{let b="",p=[],P;try{if(s==="unknown")throw new Error(`Invalid function type ${t.join(", ")}`);if(!U.includes(l))throw new Error(`Invalid mode: ${l}, must be one of ${U.join(", ")}`);typeof a=="string"&&(a=new Function("return "+a)()),typeof o=="string"&&(o=new Function("return "+o)()),typeof f=="string"&&(f=new Function("return "+f)());const n=(o-a)/f;if(isNaN(n)||n===0)throw new Error(`Invalid step ${n}`);N||(["linear","linear-horizontal"].includes(s)&&!Object.keys(S.sound).some(d=>t[0].match(new RegExp(`\\b${d}\\b`)))?N="auto":N="size");for(let d=0;d<r.length;d++){const[m,w]=r[d],_=new Function("","return "+w)();T[m]=self[m],self[m]=_}u&&Object.entries(u).forEach(([d,m])=>{!m||(self[`$rec${d}`]=w=>{const _=~~Math.round(w*m.sampleRate);return _>=0&&_<m.buffer.length?m.buffer[_]:0})}),self._state={sampleRate:i};const h=t.map(d=>new Function(Y[s],"return "+d));if(R===1){P=new Float32Array((o-a)/n);let d=0;for(let m=a;m<o;m+=n){const w=h[0](m);if(typeof w!="number"){let _;throw typeof w=="function"?_=new Error(self.__doc__[w]||"Function not supported"):typeof w>"u"?_=new Error(`${t[0]} is undefined`):_=new Error(`${typeof w} is not a number`),_}P[d++]=w}}else R===2&&(N==="size"?p=H(h,s,g,a,o,n):N==="adaptative"?p=V(h,s,g,a,o,n):N==="auto"&&(p=X(h,s,g,a,o,n)),P=new Float32Array(p));u&&Object.keys(u).forEach(d=>{delete self[`$rec${d}`]});for(let d=0;d<r.length;d++){const[m]=r[d];self[m]=T[m],delete T[m]}}catch(n){b=n}postMessage({index:e,values:P,type:s,mode:l,err:b,uuid:M},P==null?void 0:P.buffer)}})();

(function(){"use strict";var V={adsr:"adsr usage: (x, attack = 0.2, decay = 0.1, sustain = 0.4, release = 0.3, sustainLevel = 0.5)",osc:"osc usage: (freq, x, type = sine|square|smoothsquare|sawtooth|triangle, e = 0.01)",oscs:"oscs usage: (freqs, x, type = sine|square|smoothsquare|sawtooth|triangle, e = 0.01)",lowPass:"lowPass usage: (f, x, _, rc = 0.0005, sampleRate = 44100)",highPass:"highPass usage: (f, x, _, rc = 0.0005, sampleRate = 44100)",segment:"segment usage: (x, ...pairs)",at:"at usage: (d, f, x)",abs:"Returns the absolute value of x.",acos:"Returns the arccosine of x.",acosh:"Returns the hyperbolic arccosine of x.",asin:"Returns the arcsine of x.",asinh:"Returns the hyperbolic arcsine of a number.",atan:"Returns the arctangent of x.",atanh:"Returns the hyperbolic arctangent of x.",atan2:"Returns the arctangent of the quotient of its arguments.",cbrt:"Returns the cube root of x.",ceil:"Returns the smallest integer greater than or equal to x.",clz32:"Returns the number of leading zero bits of the 32-bit integer x.",cos:"Returns the cosine of x.",cosh:"Returns the hyperbolic cosine of x.",exp:"Returns ex, where x is the argument, and e is Euler's constant (2.718\u2026, the base of the natural logarithm).",expm1:"Returns subtracting 1 from exp(x).",floor:"Returns the largest integer less than or equal to x.",fround:"Returns the nearest single precision float representation of x.",hypot:"Returns the square root of the sum of squares of its arguments.",imul:"Returns the result of the 32-bit integer multiplication of x and y.",log:"Returns the natural logarithm (\u33D2e; also, \u33D1) of x.",log1p:"Returns the natural logarithm (\u33D2e; also \u33D1) of 1 + x for the number x.",log10:"Returns the base-10 logarithm of x.",log2:"Returns the base-2 logarithm of x.",max:"Returns the largest of zero or more numbers.",min:"Returns the smallest of zero or more numbers.",pow:"Returns base x to the exponent power y (that is, xy).",random:"Returns a pseudo-random number between 0 and 1.",round:"Returns the value of the number x rounded to the nearest integer.",sign:"Returns the sign of the x, indicating whether x is positive, negative, or zero.",sin:"Returns the sine of x.",sinh:"Returns the hyperbolic sine of x.",sqrt:"Returns the positive square root of x.",tan:"Returns the tangent of x.",tanh:"Returns the hyperbolic tangent of x.",trunc:"Returns the integer portion of x, removing any fractional digits."};const Y={linear:"x","linear-horizontal":"y",polar:"o",parametric:"t"};for(let e of Array.from(Object.getOwnPropertyNames(Math)))self[e.toLowerCase()]=self[e]=Math[e];const C=self.PI;self.tau=self.TAU=self.PI*2,self.eta=self.ETA=self.PI/2,self.ln=self.log,self.osc=(e,t,n="sine",i=.01)=>t<0?0:n==="sine"?Math.sin(2*Math.PI*e*t):n==="square"?Math.sign(Math.sin(2*Math.PI*e*t)):n==="smoothsquare"?Math.sin(2*Math.PI*e*t)/Math.sqrt(Math.sin(2*Math.PI*e*t)**2+i):n==="sawtooth"?2*(t*e-~~(t*e+.5)):n==="triangle"?2*Math.abs(2*(t*e+.25-~~(t*e+.75)))-1:0,self.oscs=(e,t,n,i)=>{let s=0;e=Array.isArray(e)?e:[e];for(let u=0;u<e.length;u++)s+=self.osc(e[u],t,n,i);return s/e.length},self.adsr=(e,t=.2,n=.1,i=.4,s=.3,u=.5)=>e<0?0:e<=t?e/t:e<=t+n?1-(1-u)*(e-t)/n:e<=t+n+i?u:e<=t+n+i+s?u-(u-0)*(e-t-n-i)/s:0,self.lowPass=(e,t,n,i=5e-4,s=44100)=>n+(e(t)-n)/(i*s+1),self.highPass=(e,t,n,i=5e-4,s=44100)=>(n+e(t)-e(t-1/s))*(i/(i+1/s)),self.segment=(e,...t)=>{for(let n=0;n<t.length;n+=2)if(e<t[n])return t[n+1]},self.at=(e,t,n)=>t(n+e),self.__doc__=Object.fromEntries(Object.entries(V).map((e,t)=>[self[e],t]));const A={epsilon:1e-9,sampling:1500,subsampling:32,minBlockSize:10,precisionPass:8,precision:C/1024,extremumPass:32,straightness:1e-5,maxPoints:1e4,overflow:.1},O=(e,t,n,i,s)=>{var u,N;if(isNaN(t)||isNaN(n)||t<i[0][0]||t>i[0][1]||n<i[1][0]||n>i[1][1]){(u=e.out)!=null&&u.length||e.length>0&&e.push(t,n),e.out=[t,n];return}(N=e.out)!=null&&N.length&&(s==="linear-horizontal"?e.push(NaN,((e[e.length-1]||i[1][0])+e.out[1])/2):s==="linear"?e.push(((e[e.length-2]||i[0][0])+e.out[0])/2,NaN):e.push(NaN,NaN),e.push(...e.out),e.out.splice(0)),e.push(t,n)},L=(e,t,n,i,s,u,N,h)=>{if(n==="linear"){const c=h*i+(1-h)*u,l=t[0](c);e(c,l)}else if(n==="linear-horizontal"){const c=h*s+(1-h)*N,l=t[0](c);e(l,c)}},B=(e,t,n,i,s)=>{const[[u,N],[h,c]]=i,l=[],f=(g,m)=>O(l,g,m,i,n),P=(g,m,d,M,o)=>L(f,t,n,g,m,d,M,o),R=(c-h)/(N-u);let a=0;for(let g=0;g+a<e.length;g+=4){const m=e[g],d=e[g+1],M=e[g+2+a],o=e[g+3+a],r=e[g+4+a],v=e[g+5+a];if(n==="linear"&&(isNaN(d)||isNaN(o)||isNaN(v))||n==="linear-horizontal"&&(isNaN(m)||isNaN(M)||isNaN(r))){g+=a,a=0,f(m,d),f(M,o);continue}const w=Math.atan2(o-d,R*(M-m)),p=Math.atan2(v-o,R*(r-M))-w,x=Math.abs(p),b=((r-m)/(N-u))**2+((v-d)/(c-h))**2;if(x*b<A.straightness){g-=4,a+=2;continue}if(a&&(g+=a,a=0),s){f(m,d),f(M,o);continue}const k=x>A.precision;f(m,d),k&&P(m,d,M,o,1/2),f(M,o),k&&P(M,o,r,v,1/2)}return l},X=(e,t,n,i)=>{for(let s=2;s<e.length-2;s+=2){let u=e[s-2],N=e[s-1],h=e[s],c=e[s+1],l=e[s+2],f=e[s+3];const P=i[n==="linear-horizontal"?0:1];if(n==="linear-horizontal"&&([u,N]=[N,u],[h,c]=[c,h],[l,f]=[f,l]),isNaN(c)||isNaN(f)||isNaN(N))continue;const R=Math.sign(c-N),a=Math.sign(f-c);if(R!==a){let g=u,m=h,d=l,M=c;for(let o=0;o<A.extremumPass;o++){const r=(g+m)/2,v=t[0](r),w=(m+d)/2,E=t[0](w);if(Math.sign(v-M)===R?(d=m,m=r,M=v):Math.sign(E-M)===R?(g=m,m=w,M=E):(g=r,d=w),g===d||M>P[1]||M<P[0])break}e[s]=m,e[s+1]=M,n==="linear-horizontal"&&([e[s],e[s+1]]=[e[s+1],e[s]])}}},D=(e,t,n,i,s,u)=>{let N=[],h,c,l=0;for(let f=i;f<s;f+=u)[h,c,l]=$(e,t,f,l),O(N,h,c,n,t);N=B(N,e,t,n,!0),X(N,e,t,n);for(let f=0;f<A.precisionPass&&!(N.length>A.maxPoints);f++)N=B(N,e,t,n);return N},H=(e,t,n,i,s,u)=>{const N=s-i;i-=N*A.overflow/2,s+=N*A.overflow/2;const h=[];let c=0,l=[NaN,NaN],f=[NaN,NaN],P=$(e,t,i,c);const[R,a]=t==="linear-horizontal"?[1,0]:[0,1],g=n[t==="linear-horizontal"?0:1],m=n[t==="linear-horizontal"?1:0],d=(g[1]-g[0])/(m[1]-m[0]),M=(m[1]-m[0])*A.epsilon;let o=null,r={min:[],max:[]},v=!1;for(let w=i;w<=s;w+=u){if(f=l,l=P,P=$(e,t,w+u,c),c=P[2],isNaN(l[a])||isNaN(P[a])){h.push(l[0],l[1]);continue}if(!isNaN(f[a])&&!o&&w<s-u){const z=Math.atan2(l[a]-f[a],d*(l[R]-f[R])),_=Math.atan2(P[a]-l[a],d*(P[R]-l[R]))-z,j=Math.abs(_),T=((P[R]-f[R])/(m[1]-m[0]))**2+((P[a]-f[a])/(g[1]-g[0]))**2;if(j*T<A.straightness){v=!0,l=f;continue}else v&&(v=!1,w-=u,P=l,l=f)}o||h.push(l[0],l[1]);let E=l[R],p=P[R],x=$(e,t,E+(p-E)/3,c),b=$(e,t,p-(p-E)/3,c);const k=Math.sign(x[a]-l[a]),U=Math.sign(b[a]-x[a]),F=Math.sign(P[a]-b[a]),G=F===-1?"max":"min";if(k!==U||U!==F)for(let z=0;z<A.extremumPass;z++){if(x[a]>g[1]&&b[a]<g[0]||x[a]<g[0]&&b[a]>g[1]){const I=$(e,t,(E+p)/2,c),_=Math.sign(I[a]-x[a]),j=Math.sign(b[a]-I[a]);if(_!==j){x[a]>b[a]?(r.max.push(x),r.min.push(b)):(r.max.push(b),r.min.push(x)),o?x[a]>b[a]?(o.max.push(x[0],x[1]),o.min.push(b[0],b[1])):(o.max.push(b[0],b[1]),o.min.push(x[0],x[1])):(h.push(x[0],x[1]),t==="linear-horizontal"?h.push(NaN,(x[1]+b[1])/2):h.push((x[0]+b[0])/2,NaN),h.push(b[0],b[1]));break}}if(F===-1?x[a]<b[a]?E=x[R]:p=b[R]:x[a]>b[a]?E=x[R]:p=b[R],Math.abs(p-E)<M||z===A.extremumPass-1){F===-1&&x[a]>b[a]||F===1&&x[a]<b[a]?(r[G].push(x),o?o[G].push(x[0],x[1]):h.push(x[0],x[1])):(r[G].push(b),o?o[G].push(b[0],b[1]):h.push(b[0],b[1]));break}x=$(e,t,E+(p-E)/3,c),b=$(e,t,p-(p-E)/3,c)}else if(r.max.length+r.min.length>0){let z=null,I=0,_=!1;for(let j=0;j<=A.subsampling;j++){let T=j===0?l:j===A.subsampling?P:$(e,t,((A.subsampling-j)*l[R]+j*P[R])/A.subsampling,c);if(z){const q=Math.sign(T[a]-z[a]);if(I&&q!==I){r[q===-1?"max":"min"].push(T),_=!0;break}I=q}z=T}_||(r.min.shift(),r.max.shift())}else r.min.shift(),r.max.shift();if(r.min.length>3&&r.min.shift(),r.max.length>3&&r.max.shift(),o){if(r.min.length<1&&r.max.length<1||w>s-u){if(o.min.length>2&&o.max.length>2){h.push(NaN,NaN);for(let z=0;z<o.min.length;z+=2)h.push(o.min[z],o.min[z+1]);t==="linear-horizontal"?(h.push(o.min[o.min.length-2],l[1]),h.push(o.max[o.max.length-2],l[1])):(h.push(l[0],o.min[o.min.length-1]),h.push(l[0],o.max[o.max.length-1]));for(let z=o.max.length-2;z>=0;z-=2)h.push(o.max[z],o.max[z+1]);h.push(NaN,NaN)}h.push(l[0],l[1]),o=null}}else if(r.min.length>=1&&r.max.length>=1){const z=r.min[r.min.length-1],I=r.max[r.max.length-1],_=Math.min(z[R],I[R]);o={min:t==="linear-horizontal"?[z[a],_]:[_,z[a]],max:t==="linear-horizontal"?[I[a],_]:[_,I[a]]}}}return h.push(P[0],P[1]),h},J=(e,t,n,i,s,u)=>{const N=[];let h,c,l=0;for(let f=i;f<s;f+=u)[h,c,l]=$(e,t,f,l),O(N,h,c,n,t);return N},$=(e,t,n,i)=>{if(t==="parametric"){i=Array.isArray(i)?i:[0,0];const s=e[0](n,i[0]),u=e[1](n,i[1]);return[s,u,[s,u]]}else if(t==="polar"){const s=e[0](n,i);return[s*Math.cos(n),s*Math.sin(n),s]}else if(t==="linear-horizontal"){const s=e[0](n,i);return[s,n,s]}else if(t==="linear"){const s=e[0](n,i);return[n,s,s]}throw new Error(`Unknown plot type ${t}`)},S=["line","dot","point"],y={};onmessage=({data:{index:e,funs:t,type:n,min:i,max:s,samples:u,region:N,affects:h,mode:c,rendering:l,recs:f,dimensions:P=2,uuid:R}})=>{let a="",g=[],m;try{if(n==="unknown")throw new Error(`Invalid function type ${t.join(", ")}`);if(!S.includes(c))throw new Error(`Invalid mode: ${c}, must be one of ${S.join(", ")}`);typeof i=="string"&&(i=new Function("return "+i)()),typeof s=="string"&&(s=new Function("return "+s)()),typeof u=="string"&&(u=new Function("return "+u)());const d=(s-i)/u;if(isNaN(d)||d===0)throw new Error(`Invalid step ${d}`);l||(["linear","linear-horizontal"].includes(n)?l="auto":l="size");for(let o=0;o<h.length;o++){const[r,v]=h[o],w=new Function("","return "+v)();y[r]=self[r],self[r]=w}f&&Object.entries(f).forEach(([o,r])=>{!r||(self[`$rec${o}`]=v=>{const w=~~Math.round(v*r.sampleRate);return w>=0&&w<r.buffer.length?r.buffer[w]:0})});const M=t.map(o=>new Function(Y[n],"_","return "+o));if(P===1){m=new Float32Array((s-i)/d);let o=0,r=0;for(let v=i;v<s;v+=d){const w=M[0](v,r);if(r=w,typeof w!="number"){let E;throw typeof w=="function"?E=new Error(self.__doc__[w]||"Function not supported"):typeof w>"u"?E=new Error(`${t[0]} is undefined`):E=new Error(`${typeof w} is not a number`),E}m[o++]=w}}else P===2&&(l==="size"?g=J(M,n,N,i,s,d):l==="adaptative"?g=D(M,n,N,i,s,d):l==="auto"&&(g=H(M,n,N,i,s,d)),m=new Float32Array(g));f&&Object.keys(f).forEach(o=>{delete self[`$rec${o}`]});for(let o=0;o<h.length;o++){const[r]=h[o];self[r]=y[r],delete y[r]}}catch(d){a=d}postMessage({index:e,values:m,type:n,mode:c,err:a,uuid:R},m==null?void 0:m.buffer)}})();

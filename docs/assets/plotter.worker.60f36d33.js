(function(){"use strict";const m={linear:"x","linear-horizontal":"y",polar:"o",parametric:"t"};for(let n of Array.from(Object.getOwnPropertyNames(Math)))self[n.toLowerCase()]=self[n]=Math[n];self.TAU=self.PI*2,self.osc=(n,s,o="sine")=>s<0?0:o==="sine"?Math.sin(2*Math.PI*n*s):o==="square"?Math.sign(Math.sin(2*Math.PI*n*s)):o==="sawtooth"?2*(s*n-~~(s*n+.5)):o==="triangle"?2*Math.abs(2*(s*n+.25-~~(s*n+.75)))-1:0,self.adsr=(n,s=.2,o=.1,r=.4,a=.3,f=.5)=>n<0?0:n<=s?n/s:n<=s+o?1-(1-f)*(n-s)/o:n<=s+o+r?f:n<=s+o+r+a?f-(f-0)*(n-s-o-r)/a:0,self.__doc__={[self.adsr]:"adsr usage: (x, attack = 0.2, decay = 0.1, sustain = 0.4, release = 0.3, sustainLevel = 0.5)",[self.osc]:"osc usage: (freq, x, type = sine|square|sawtooth|triangle)",[self.abs]:"Returns the absolute value of x.",[self.acos]:"Returns the arccosine of x.",[self.acosh]:"Returns the hyperbolic arccosine of x.",[self.asin]:"Returns the arcsine of x.",[self.asinh]:"Returns the hyperbolic arcsine of a number.",[self.atan]:"Returns the arctangent of x.",[self.atanh]:"Returns the hyperbolic arctangent of x.",[self.atan2]:"Returns the arctangent of the quotient of its arguments.",[self.cbrt]:"Returns the cube root of x.",[self.ceil]:"Returns the smallest integer greater than or equal to x.",[self.clz32]:"Returns the number of leading zero bits of the 32-bit integer x.",[self.cos]:"Returns the cosine of x.",[self.cosh]:"Returns the hyperbolic cosine of x.",[self.exp]:"Returns ex, where x is the argument, and e is Euler's constant (2.718\u2026, the base of the natural logarithm).",[self.expm1]:"Returns subtracting 1 from exp(x).",[self.floor]:"Returns the largest integer less than or equal to x.",[self.fround]:"Returns the nearest single precision float representation of x.",[self.hypot]:"Returns the square root of the sum of squares of its arguments.",[self.imul]:"Returns the result of the 32-bit integer multiplication of x and y.",[self.log]:"Returns the natural logarithm (\u33D2e; also, \u33D1) of x.",[self.log1p]:"Returns the natural logarithm (\u33D2e; also \u33D1) of 1 + x for the number x.",[self.log10]:"Returns the base-10 logarithm of x.",[self.log2]:"Returns the base-2 logarithm of x.",[self.max]:"Returns the largest of zero or more numbers.",[self.min]:"Returns the smallest of zero or more numbers.",[self.pow]:"Returns base x to the exponent power y (that is, xy).",[self.random]:"Returns a pseudo-random number between 0 and 1.",[self.round]:"Returns the value of the number x rounded to the nearest integer.",[self.sign]:"Returns the sign of the x, indicating whether x is positive, negative, or zero.",[self.sin]:"Returns the sine of x.",[self.sinh]:"Returns the hyperbolic sine of x.",[self.sqrt]:"Returns the positive square root of x.",[self.tan]:"Returns the tangent of x.",[self.tanh]:"Returns the hyperbolic tangent of x.",[self.trunc]:"Returns the integer portion of x, removing any fractional digits."};const u={};onmessage=({data:{index:n,funs:s,type:o,values:r,affects:a,recs:f,dimensions:c=2,uuid:R}})=>{let g="",b=[0];try{for(let e=0;e<a.length;e++){const[t,l]=a[e],h=new Function("","return "+l)();u[t]=self[t],self[t]=h}f&&Object.entries(f).forEach(([e,t])=>{!t||(self[`$rec${e}`]=l=>{const h=~~Math.round(l*t.sampleRate);return h>=0&&h<t.buffer.length?t.buffer[h]:0})});const i=s.map(e=>new Function(m[o],"return "+e));for(let e=0;e<r.length;e+=c)if(c===1){const t=i[0](r[e]);if(typeof t!="number"){let l;throw typeof t=="function"?l=new Error(self.__doc__[t]||"Function not supported"):typeof t>"u"?l=new Error(`${s[0]} is undefined`):l=new Error(`${typeof t} is not a number`),l}r[e]=t}else if(o==="parametric"){const t=r[e];r[e]=i[0](t),r[e+1]=i[1](t)}else if(o==="linear-horizontal")r[e]=i[0](r[e+1]);else if(r[e+1]=i[0](r[e]),o==="polar"){const t=r[e];r[e]=r[e+1]*Math.cos(t),r[e+1]*=Math.sin(t)}f&&Object.keys(f).forEach(e=>{delete self[`$rec${e}`]});for(let e=0;e<a.length;e++){const[t]=a[e];self[t]=u[t],delete u[t]}}catch(i){g=i}postMessage({index:n,values:r,type:o,skips:b,err:g,uuid:R},[r.buffer])}})();

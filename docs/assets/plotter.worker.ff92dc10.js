(function(){"use strict";function Y(e,t,s){return Math.max(t,Math.min(s,e))}const p={linear:"x","linear-horizontal":"y",polar:"o",parametric:"t"};for(let e of Array.from(Object.getOwnPropertyNames(Math)))self[e.toLowerCase()]=self[e]=Math[e];const C=self.PI;self.tau=self.TAU=self.PI*2,self.eta=self.ETA=self.PI/2,self.ln=self.log,self.osc=(e,t,s="sine")=>t<0?0:s==="sine"?Math.sin(2*Math.PI*e*t):s==="square"?Math.sign(Math.sin(2*Math.PI*e*t)):s==="sawtooth"?2*(t*e-~~(t*e+.5)):s==="triangle"?2*Math.abs(2*(t*e+.25-~~(t*e+.75)))-1:0,self.adsr=(e,t=.2,s=.1,i=.4,a=.3,N=.5)=>e<0?0:e<=t?e/t:e<=t+s?1-(1-N)*(e-t)/s:e<=t+s+i?N:e<=t+s+i+a?N-(N-0)*(e-t-s-i)/a:0,self.__doc__={[self.adsr]:"adsr usage: (x, attack = 0.2, decay = 0.1, sustain = 0.4, release = 0.3, sustainLevel = 0.5)",[self.osc]:"osc usage: (freq, x, type = sine|square|sawtooth|triangle)",[self.abs]:"Returns the absolute value of x.",[self.acos]:"Returns the arccosine of x.",[self.acosh]:"Returns the hyperbolic arccosine of x.",[self.asin]:"Returns the arcsine of x.",[self.asinh]:"Returns the hyperbolic arcsine of a number.",[self.atan]:"Returns the arctangent of x.",[self.atanh]:"Returns the hyperbolic arctangent of x.",[self.atan2]:"Returns the arctangent of the quotient of its arguments.",[self.cbrt]:"Returns the cube root of x.",[self.ceil]:"Returns the smallest integer greater than or equal to x.",[self.clz32]:"Returns the number of leading zero bits of the 32-bit integer x.",[self.cos]:"Returns the cosine of x.",[self.cosh]:"Returns the hyperbolic cosine of x.",[self.exp]:"Returns ex, where x is the argument, and e is Euler's constant (2.718\u2026, the base of the natural logarithm).",[self.expm1]:"Returns subtracting 1 from exp(x).",[self.floor]:"Returns the largest integer less than or equal to x.",[self.fround]:"Returns the nearest single precision float representation of x.",[self.hypot]:"Returns the square root of the sum of squares of its arguments.",[self.imul]:"Returns the result of the 32-bit integer multiplication of x and y.",[self.log]:"Returns the natural logarithm (\u33D2e; also, \u33D1) of x.",[self.log1p]:"Returns the natural logarithm (\u33D2e; also \u33D1) of 1 + x for the number x.",[self.log10]:"Returns the base-10 logarithm of x.",[self.log2]:"Returns the base-2 logarithm of x.",[self.max]:"Returns the largest of zero or more numbers.",[self.min]:"Returns the smallest of zero or more numbers.",[self.pow]:"Returns base x to the exponent power y (that is, xy).",[self.random]:"Returns a pseudo-random number between 0 and 1.",[self.round]:"Returns the value of the number x rounded to the nearest integer.",[self.sign]:"Returns the sign of the x, indicating whether x is positive, negative, or zero.",[self.sin]:"Returns the sine of x.",[self.sinh]:"Returns the hyperbolic sine of x.",[self.sqrt]:"Returns the positive square root of x.",[self.tan]:"Returns the tangent of x.",[self.tanh]:"Returns the hyperbolic tangent of x.",[self.trunc]:"Returns the integer portion of x, removing any fractional digits."};const $={epsilon:1e-9,sampling:1500,subsampling:2,minBlockSize:10,precisionPass:8,precision:C/1024,extremumPass:32,straightness:1e-5,maxPoints:1e4},T=(e,t,s,i,a)=>{var N,o;if(isNaN(t)||isNaN(s)||t<i[0][0]||t>i[0][1]||s<i[1][0]||s>i[1][1]){(N=e.out)!=null&&N.length||e.length>0&&e.push(t,s),e.out=[t,s];return}(o=e.out)!=null&&o.length&&(a==="linear-horizontal"?e.push(NaN,((e[e.length-1]||i[1][0])+e.out[1])/2):a==="linear"?e.push(((e[e.length-2]||i[0][0])+e.out[0])/2,NaN):e.push(NaN,NaN),e.push(...e.out),e.out.splice(0)),e.push(t,s)},L=(e,t,s,i,a,N,o,n)=>{if(s==="linear"){const c=n*i+(1-n)*N,f=t[0](c);e(c,f)}else if(s==="linear-horizontal"){const c=n*a+(1-n)*o,f=t[0](c);e(f,c)}},O=(e,t,s,i,a)=>{const[[N,o],[n,c]]=i,f=[],g=(d,x)=>T(f,d,x,i,s),l=(d,x,r,h,u)=>L(g,t,s,d,x,r,h,u),z=(c-n)/(o-N);let M=0;for(let d=0;d+M<e.length;d+=4){const x=e[d],r=e[d+1],h=e[d+2+M],u=e[d+3+M],m=e[d+4+M],b=e[d+5+M];if(s==="linear"&&(isNaN(r)||isNaN(u)||isNaN(b))||s==="linear-horizontal"&&(isNaN(x)||isNaN(h)||isNaN(m))){d+=M,M=0,g(x,r),g(h,u);continue}const R=Math.atan2(u-r,z*(h-x)),P=Math.atan2(b-u,z*(m-h))-R,k=Math.abs(P),G=((m-x)/(o-N))**2+((b-r)/(c-n))**2;if(k*G<$.straightness){d-=4,M+=2;continue}if(M&&(d+=M,M=0),a){g(x,r),g(h,u);continue}const I=k>$.precision;g(x,r),I&&l(x,r,h,u,1/2),g(h,u),I&&l(h,u,m,b,1/2)}return f},V=(e,t,s,i)=>{for(let a=2;a<e.length-2;a+=2){let N=e[a-2],o=e[a-1],n=e[a],c=e[a+1],f=e[a+2],g=e[a+3];const l=i[s==="linear-horizontal"?0:1];if(s==="linear-horizontal"&&([N,o]=[o,N],[n,c]=[c,n],[f,g]=[g,f]),isNaN(c)||isNaN(g)||isNaN(o))continue;const z=Math.sign(c-o),M=Math.sign(g-c);if(z!==M){let d=N,x=n,r=f,h=c;for(let u=0;u<$.extremumPass;u++){const m=(d+x)/2,b=t[0](m),R=(x+r)/2,w=t[0](R);if(Math.sign(b-h)===z?(r=x,x=m,h=b):Math.sign(w-h)===z?(d=x,x=R,h=w):(d=m,r=R),d===r||h>l[1]||h<l[0])break}e[a]=x,e[a+1]=h,s==="linear-horizontal"&&([e[a],e[a+1]]=[e[a+1],e[a]])}}},X=(e,t,s,i,a,N)=>{let o=[];for(let n=i;n<a;n+=N){const[c,f]=E(e,n,t);T(o,c,f,s,t)}o=O(o,e,t,s,!0),V(o,e,t,s);for(let n=0;n<$.precisionPass&&!(o.length>$.maxPoints);n++)o=O(o,e,t,s);return o},y=(e,t,s,i,a,N)=>{const o=[];let n=[NaN,NaN],c=[NaN,NaN],f=E(e,i,t);const[g,l]=t==="linear-horizontal"?[1,0]:[0,1],z=s[t==="linear-horizontal"?0:1],M=s[t==="linear-horizontal"?1:0],d=(z[1]-z[0])/(M[1]-M[0]),x=(M[1]-M[0])*$.epsilon;let r=null,h=0,u=!1;for(let m=i;m<=a;m+=N){if(c=n,n=f,f=E(e,m+N,t),isNaN(n[l])||isNaN(f[l])){o.push(n[0],n[1]);continue}if(!isNaN(c[l])&&!r&&m<a-N){const v=Math.atan2(n[l]-c[l],d*(n[g]-c[g])),F=Math.atan2(f[l]-n[l],d*(f[g]-n[g]))-v,j=Math.abs(F),A=((f[g]-c[g])/(M[1]-M[0]))**2+((f[l]-c[l])/(z[1]-z[0]))**2;if(j*A<$.straightness){u=!0,n=c;continue}else u&&(u=!1,m-=N,f=n,n=c)}r||o.push(n[0],n[1]);let b=n[g],R=f[g],w=E(e,b+(R-b)/3,t),P=E(e,R-(R-b)/3,t);const k=Math.sign(w[l]-n[l]),G=Math.sign(P[l]-w[l]),I=Math.sign(f[l]-P[l]);if(k!==G||G!==I){h++;for(let v=0;v<$.extremumPass;v++){if(w[l]>z[1]&&P[l]<z[0]||w[l]<z[0]&&P[l]>z[1]){const _=E(e,(b+R)/2,t),F=Math.sign(_[l]-w[l]),j=Math.sign(P[l]-_[l]);if(!r&&F!==j){o.push(w[0],w[1]),t==="linear-horizontal"?o.push(NaN,(w[1]+P[1])/2):o.push((w[0]+P[0])/2,NaN),o.push(P[0],P[1]);break}}if(I===-1?w[l]<P[l]?b=w[g]:R=P[g]:w[l]>P[l]?b=w[g]:R=P[g],Math.abs(R-b)<x||v===$.extremumPass-1){I===-1&&w[l]>P[l]||I===1&&w[l]<P[l]?r?r[I===-1?"max":"min"].push(w[0],w[1]):o.push(w[0],w[1]):r?r[I===-1?"max":"min"].push(P[0],P[1]):o.push(P[0],P[1]);break}w=E(e,b+(R-b)/3,t),P=E(e,R-(R-b)/3,t)}}else if(h>0){let _=null,F=0,j=!1;for(let A=0;A<=20;A++){let S=A===0?n:A===20?f:E(e,((20-A)*n[g]+A*f[g])/20,t);if(_){const U=Math.sign(S[l]-_[l]);if(F&&U!==F){j=!0;break}F=U}_=S}j?h++:h--}else h--;if(h=Y(h,0,3),r){if(h<1||m>a-N){o.push(NaN,NaN);for(let v=0;v<r.min.length;v+=2)o.push(r.min[v],r.min[v+1]);o.push(n[0],n[1]);for(let v=r.max.length-2;v>=0;v-=2)o.push(r.max[v],r.max[v+1]);o.push(NaN,NaN),o.push(n[0],n[1]),r=null}}else h>1&&(r={min:n.slice(),max:n.slice()})}return o.push(f[0],f[1]),o},D=(e,t,s,i,a,N)=>{const o=[];for(let n=i;n<a;n+=N){const[c,f]=E(e,n,t);T(o,c,f,s,t)}return o},E=(e,t,s)=>{if(s==="parametric")return[e[0](t),e[1](t)];if(s==="polar"){const i=e[0](t);return[i*Math.cos(t),i*Math.sin(t)]}else{if(s==="linear-horizontal")return[e[0](t),t];if(s==="linear")return[t,e[0](t)]}throw new Error(`Unknown plot type ${s}`)},B=["line","dot","point"],q={};onmessage=({data:{index:e,funs:t,type:s,min:i,max:a,samples:N,region:o,affects:n,mode:c,rendering:f,recs:g,dimensions:l=2,uuid:z}})=>{let M="",d=[],x;try{if(s==="unknown")throw new Error(`Invalid function type ${t.join(", ")}`);if(!B.includes(c))throw new Error(`Invalid mode: ${c}, must be one of ${B.join(", ")}`);typeof i=="string"&&(i=new Function("return "+i)()),typeof a=="string"&&(a=new Function("return "+a)()),typeof N=="string"&&(N=new Function("return "+N)());const r=(a-i)/N;if(isNaN(r)||r===0)throw new Error(`Invalid step ${r}`);f||(["linear","linear-horizontal"].includes(s)?f="auto":f="size");for(let u=0;u<n.length;u++){const[m,b]=n[u],R=new Function("","return "+b)();q[m]=self[m],self[m]=R}g&&Object.entries(g).forEach(([u,m])=>{!m||(self[`$rec${u}`]=b=>{const R=~~Math.round(b*m.sampleRate);return R>=0&&R<m.buffer.length?m.buffer[R]:0})});const h=t.map(u=>new Function(p[s],"return "+u));if(l===1){x=new Float32Array((a-i)/r);let u=0;for(let m=i;m<a;m+=r){const b=h[0](m);if(typeof b!="number"){let R;throw typeof b=="function"?R=new Error(self.__doc__[b]||"Function not supported"):typeof b>"u"?R=new Error(`${t[0]} is undefined`):R=new Error(`${typeof b} is not a number`),R}x[u++]=b}}else l===2&&(f==="size"?d=D(h,s,o,i,a,r):f==="adaptative"?d=X(h,s,o,i,a,r):f==="auto"&&(d=y(h,s,o,i,a,r)),x=new Float32Array(d));g&&Object.keys(g).forEach(u=>{delete self[`$rec${u}`]});for(let u=0;u<n.length;u++){const[m]=n[u];self[m]=q[m],delete q[m]}}catch(r){M=r}postMessage({index:e,values:x,type:s,mode:c,err:M,uuid:z},x==null?void 0:x.buffer)}})();

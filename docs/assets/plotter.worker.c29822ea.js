(function(){"use strict";var C={sound:{adsr:"adsr usage: (x, attack = 0.2, decay = 0.1, sustain = 0.4, release = 0.3, sustainLevel = 0.5, duration = <sound duration>)",osc:"osc usage: (x, freq, type = sine|square|smoothsquare|sawtooth|triangle|noise, smooth = 0.5)",oscs:"oscs usage: (x, freqs, type = sine|square|smoothsquare|sawtooth|triangle|noise, smooth = 0.5)",sine:"sine usage: (x, freq)",square:"square usage: (x, freq)",smoothsquare:"smoothsquare usage: (x, freq, smooth = 0.5)",sawtooth:"sawtooth usage: (x, freq)",triangle:"triangle usage: (x, freq)",noise:"noise usage: (x)",lowpass:"lowpass usage: (x, input, cutoff)",highpass:"highpass usage: (x, input, cutoff)",segment:"segment usage: (x, ...pairs)",at:"at usage: (d, f, x)"},math:{abs:"Returns the absolute value of x.",acos:"Returns the arccosine of x.",acosh:"Returns the hyperbolic arccosine of x.",asin:"Returns the arcsine of x.",asinh:"Returns the hyperbolic arcsine of a number.",atan:"Returns the arctangent of x.",atanh:"Returns the hyperbolic arctangent of x.",atan2:"Returns the arctangent of the quotient of its arguments.",cbrt:"Returns the cube root of x.",ceil:"Returns the smallest integer greater than or equal to x.",clz32:"Returns the number of leading zero bits of the 32-bit integer x.",cos:"Returns the cosine of x.",cosh:"Returns the hyperbolic cosine of x.",exp:"Returns ex, where x is the argument, and e is Euler's constant (2.718\u2026, the base of the natural logarithm).",expm1:"Returns subtracting 1 from exp(x).",floor:"Returns the largest integer less than or equal to x.",fround:"Returns the nearest single precision float representation of x.",hypot:"Returns the square root of the sum of squares of its arguments.",imul:"Returns the result of the 32-bit integer multiplication of x and y.",log:"Returns the natural logarithm (\u33D2e; also, \u33D1) of x.",log1p:"Returns the natural logarithm (\u33D2e; also \u33D1) of 1 + x for the number x.",log10:"Returns the base-10 logarithm of x.",log2:"Returns the base-2 logarithm of x.",max:"Returns the largest of zero or more numbers.",min:"Returns the smallest of zero or more numbers.",pow:"Returns base x to the exponent power y (that is, xy).",random:"Returns a pseudo-random number between 0 and 1.",round:"Returns the value of the number x rounded to the nearest integer.",sign:"Returns the sign of the x, indicating whether x is positive, negative, or zero.",sin:"Returns the sine of x.",sinh:"Returns the hyperbolic sine of x.",sqrt:"Returns the positive square root of x.",tan:"Returns the tangent of x.",tanh:"Returns the hyperbolic tangent of x.",trunc:"Returns the integer portion of x, removing any fractional digits."},constant:{e:"Euler's constant and the base of natural logarithms; approximately 2.718.",ln2:"Natural logarithm of 2; approximately 0.693.",ln10:"Natural logarithm of 10; approximately 2.303.",log2e:"Base-2 logarithm of E; approximately 1.443.",log10e:"Base-10 logarithm of E; approximately 0.434.",pi:"Ratio of a circle's circumference to its diameter; approximately 3.14159.",sqrt1_2:"Square root of \xBD; approximately 0.707.",sqrt2:"Square root of 2; approximately 1.414."},util:{lerp:"lerp usage: (x, y, a)",clamp:"clamp usage: (x, min, max)"},graphit:{"@size":"Plot each pixel","@adaptative":"Adaptative plot","@auto":"Better adaptative plot","@fft":"FFT of the sound","@!":"Precision","@/dot":"Dot plot mode","@/point":"Point plot mode","@/line":"Line plot mode","@ ":"@ x0 -> x1 : Plot range [x0;x1]"}};const S=t=>t&t-1?2**(Math.log2(t)+1|0):t,D={linear:"x","linear-horizontal":"y",polar:"o",parametric:"t",sound:"t",fft:"t"};self.lerp=(t,e,s)=>t+(e-t)*s,self.clamp=(t,e,s)=>Math.min(Math.max(t,e),s);for(let t of Array.from(Object.getOwnPropertyNames(Math)))self[t.toLowerCase()]=self[t]=Math[t];const G=self.PI,A=self.tau=self.TAU=G*2;self.eta=self.ETA=G/2,self.ln=self.log,self.osc=(t,e,s="sine",i=.5)=>{const a=++self._state.call;if(self._state.n<0)return 0;self._state[a]||(self._state[a]={f:0,last_x:0});const n=self._state[a],r=t-n.last_x;n.last_x=t;const o=n.f+=self.clamp(e,0,22050)*r;switch(s){case"sine":return Math.sin(o*A);case"square":return Math.sign(Math.sin(o*A));case"smoothsquare":return Math.tanh(Math.sin(o*A)/i);case"sawtooth":return o%1*2-1;case"triangle":return Math.abs(o%1*4-2)-1;case"noise":return Math.random()*2-1;default:throw new Error(`Unknown oscillator type: ${s}`)}},self.sine=(t,e)=>self.osc(t,e,"sine"),self.square=(t,e)=>self.osc(t,e,"square"),self.smoothsquare=(t,e,s=.5)=>self.osc(t,e,"smoothsquare",s),self.sawtooth=(t,e)=>self.osc(t,e,"sawtooth"),self.triangle=(t,e)=>self.osc(t,e,"triangle"),self.noise=()=>self.osc(0,0,"noise"),self.oscs=(t,e,s,i=.5)=>{let a=0;e=Array.isArray(e)?e:[e];for(let n=0;n<e.length;n++)a+=self.osc(t,e[n],s,i);return a/e.length},self.adsr=(t,e=.2,s=.1,i=.4,a=.3,n=.5,r=null)=>(r=r||self._state.max,t=t/r,t<0?0:t<=e?t/e:t<=e+s?1-(1-n)*(t-e)/s:t<=e+s+i?n:t<=e+s+i+a?n-(n-0)*(t-e-s-i)/a:0),self.iirFilterGen=t=>(e,s,i)=>{const a=++self._state.call;if(self._state.n<0)return 0;if(!self._state[a]){const[f,u]=t(s,i);self._state[a]={a:f,b:u,x:new Array(f.length).fill(0),y:new Array(u.length).fill(0)}}const n=self._state[a],{a:r,b:o,x:l,y:m}=n;let c=0;for(let f=0;f<r.length;f++)c+=r[f]*l[f];for(let f=0;f<o.length;f++)c+=o[f]*m[f];for(let f=r.length-1;f>0;f--)l[f]=l[f-1];for(let f=o.length-1;f>0;f--)m[f]=m[f-1];return l[0]=e,m[0]=c,c},self.lowpass=self.iirFilterGen(t=>{const e=t*self._state.step,s=Math.exp(-A*e);return[[1-s],[s]]}),self.lowpass4=self.iirFilterGen(t=>{const s=t*self._state.step,i=Math.exp(-14.445*s);return[[Math.pow(1-i,4)],[4*i,-6*Math.pow(i,2),4*Math.pow(i,3),-Math.pow(i,4)]]}),self.highpass=self.iirFilterGen(t=>{const e=t*self._state.step,s=Math.exp(-A*e);return[[(1+s)/2,-(1+s)/2],[s]]}),self.bandpass=self.iirFilterGen((t,e)=>{const s=t*self._state.step,i=e*self._state.step,a=2*Math.cos(A*s),n=1-3*i,r=(1-n*a+n*n)/(2-a);return[[1-r,(r-n)*a,n*n-r],[n*a,-n*n]]}),self.bandreject=self.iirFilterGen((t,e)=>{const s=t*self._state.step,i=e*self._state.step,a=2*Math.cos(A*s),n=1-3*i,r=(1-n*a+n*n)/(2-a);return[[r,-r*a,r],[n*a,-n*n]]}),self.pulse=()=>{const t=++self._state.call;return self._state.n<0||self._state[t]?0:(self._state[t]=!0,1)},self.peak=(t,e,s=1)=>t===e?s:0,self.band=(t,e,s,i=1)=>t>e&&t<s?i:0,self.fft=(t,e)=>{const s=t.length;if(s!==e.length)throw new Error("Mismatched lengths");const i=Math.log2(s);if(i!==~~i)throw new Error("Length is not a power of 2");const a=new Float32Array(s/2),n=new Float32Array(s/2);for(var r=0;r<s/2;r++)a[r]=Math.cos(A*r/s),n[r]=Math.sin(A*r/s);for(let o=0;o<s;o++){let l=0,m=o;for(let c=0;c<i;c++)l=l<<1|m&1,m>>>=1;l>o&&([t[o],t[l]]=[t[l],t[o]],[e[o],e[l]]=[e[l],e[o]])}for(let o=2;o<=s;o*=2){const l=o/2,m=s/o;for(let c=0;c<s;c+=o)for(let f=c,u=0;f<c+l;f++,u+=m){const d=t[f+l]*a[u]+e[f+l]*n[u],x=-t[f+l]*n[u]+e[f+l]*a[u];t[f+l]=t[f]-d,e[f+l]=e[f]-x,t[f]+=d,e[f]+=x}}return[t,e]},self.segment=(t,...e)=>{for(let s=0;s<e.length;s+=2)if(t<e[s])return e[s+1]},self.at=(t,e,s)=>e(s+t),self.__doc__=Object.fromEntries(Object.entries(C).map(([t,e])=>Object.entries(e).map(([s,i])=>[self[s],`${t}: ${i}`])).flat());const q={epsilon:1e-9,sampling:1500,subsampling:32,minBlockSize:10,precisionPass:8,precision:G/1024,extremumPass:32,straightness:1e-5,maxPoints:1e4,overflow:.1},L=(t,e,s,i,a)=>{var n,r;if(isNaN(e)||isNaN(s)||e<i[0][0]||e>i[0][1]||s<i[1][0]||s>i[1][1]){(n=t.out)!=null&&n.length||t.length>0&&t.push(e,s),t.out=[e,s];return}(r=t.out)!=null&&r.length&&(a==="linear-horizontal"?t.push(NaN,((t[t.length-1]||i[1][0])+t.out[1])/2):a==="linear"?t.push(((t[t.length-2]||i[0][0])+t.out[0])/2,NaN):t.push(NaN,NaN),t.push(...t.out),t.out.splice(0)),t.push(e,s)},V=(t,e,s,i,a,n,r,o)=>{if(s==="linear"){const l=o*i+(1-o)*n,m=e[0](l);t(l,m)}else if(s==="linear-horizontal"){const l=o*a+(1-o)*r,m=e[0](l);t(m,l)}},U=(t,e,s,i,a)=>{const[[n,r],[o,l]]=i,m=[],c=(x,N)=>L(m,x,N,i,s),f=(x,N,R,h,g)=>V(c,e,s,x,N,R,h,g),u=(l-o)/(r-n);let d=0;for(let x=0;x+d<t.length;x+=4){const N=t[x],R=t[x+1],h=t[x+2+d],g=t[x+3+d],w=t[x+4+d],p=t[x+5+d];if(s==="linear"&&(isNaN(R)||isNaN(g)||isNaN(p))||s==="linear-horizontal"&&(isNaN(N)||isNaN(h)||isNaN(w))){x+=d,d=0,c(N,R),c(h,g);continue}const z=Math.atan2(g-R,u*(h-N)),M=Math.atan2(p-g,u*(w-h))-z,b=Math.abs(M),B=((w-N)/(r-n))**2+((p-R)/(l-o))**2;if(b*B<q.straightness){x-=4,d+=2;continue}if(d&&(x+=d,d=0),a){c(N,R),c(h,g);continue}const k=b>q.precision;c(N,R),k&&f(N,R,h,g,1/2),c(h,g),k&&f(h,g,w,p,1/2)}return m},X=(t,e,s,i)=>{for(let a=2;a<t.length-2;a+=2){let n=t[a-2],r=t[a-1],o=t[a],l=t[a+1],m=t[a+2],c=t[a+3];const f=i[s==="linear-horizontal"?0:1];if(s==="linear-horizontal"&&([n,r]=[r,n],[o,l]=[l,o],[m,c]=[c,m]),isNaN(l)||isNaN(c)||isNaN(r))continue;const u=Math.sign(l-r),d=Math.sign(c-l);if(u!==d){let x=n,N=o,R=m,h=l;for(let g=0;g<q.extremumPass;g++){const w=(x+N)/2,p=e[0](w),z=(N+R)/2,P=e[0](z);if(Math.sign(p-h)===u?(R=N,N=w,h=p):Math.sign(P-h)===u?(x=N,N=z,h=P):(x=w,R=z),x===R||h>f[1]||h<f[0])break}t[a]=N,t[a+1]=h,s==="linear-horizontal"&&([t[a],t[a+1]]=[t[a+1],t[a]])}}},H=(t,e,s,i,a,n)=>{let r=[];for(let o=i;o<a;o+=n){const[l,m]=v(t,e,o);L(r,l,m,s,e)}r=U(r,t,e,s,!0),X(r,t,e,s);for(let o=0;o<q.precisionPass&&!(r.length>q.maxPoints);o++)r=U(r,t,e,s);return r},J=(t,e,s,i,a,n)=>{const r=a-i;i-=r*q.overflow/2,a+=r*q.overflow/2;const o=[];let l=[NaN,NaN],m=[NaN,NaN],c=v(t,e,i);const[f,u]=e==="linear-horizontal"?[1,0]:[0,1],d=s[e==="linear-horizontal"?0:1],x=s[e==="linear-horizontal"?1:0],N=(d[1]-d[0])/(x[1]-x[0]),R=(x[1]-x[0])*q.epsilon;let h=null,g={min:[],max:[]},w=!1;for(let p=i;p<=a;p+=n){if(m=l,l=c,c=v(t,e,p+n),isNaN(l[u])||isNaN(c[u])){o.push(l[0],l[1]);continue}if(!isNaN(m[u])&&!h&&p<a-n){const _=Math.atan2(l[u]-m[u],N*(l[f]-m[f])),E=Math.atan2(c[u]-l[u],N*(c[f]-l[f]))-_,F=Math.abs(E),$=((c[f]-m[f])/(x[1]-x[0]))**2+((c[u]-m[u])/(d[1]-d[0]))**2;if(F*$<q.straightness){w=!0,l=m;continue}else w&&(w=!1,p-=n,c=l,l=m)}h||o.push(l[0],l[1]);let z=l[f],P=c[f],M=v(t,e,z+(P-z)/3),b=v(t,e,P-(P-z)/3);const B=Math.sign(M[u]-l[u]),k=Math.sign(b[u]-M[u]),T=Math.sign(c[u]-b[u]),j=T===-1?"max":"min";if(B!==k||k!==T)for(let _=0;_<q.extremumPass;_++){if(M[u]>d[1]&&b[u]<d[0]||M[u]<d[0]&&b[u]>d[1]){const y=v(t,e,(z+P)/2),E=Math.sign(y[u]-M[u]),F=Math.sign(b[u]-y[u]);if(E!==F){M[u]>b[u]?(g.max.push(M),g.min.push(b)):(g.max.push(b),g.min.push(M)),h?M[u]>b[u]?(h.max.push(M[0],M[1]),h.min.push(b[0],b[1])):(h.max.push(b[0],b[1]),h.min.push(M[0],M[1])):(o.push(M[0],M[1]),e==="linear-horizontal"?o.push(NaN,(M[1]+b[1])/2):o.push((M[0]+b[0])/2,NaN),o.push(b[0],b[1]));break}}if(T===-1?M[u]<b[u]?z=M[f]:P=b[f]:M[u]>b[u]?z=M[f]:P=b[f],Math.abs(P-z)<R||_===q.extremumPass-1){T===-1&&M[u]>b[u]||T===1&&M[u]<b[u]?(g[j].push(M),h?h[j].push(M[0],M[1]):o.push(M[0],M[1])):(g[j].push(b),h?h[j].push(b[0],b[1]):o.push(b[0],b[1]));break}M=v(t,e,z+(P-z)/3),b=v(t,e,P-(P-z)/3)}else if(g.max.length+g.min.length>0){let _=null,y=0,E=!1;for(let F=0;F<=q.subsampling;F++){let $=F===0?l:F===q.subsampling?c:v(t,e,((q.subsampling-F)*l[f]+F*c[f])/q.subsampling);if(_){const I=Math.sign($[u]-_[u]);if(y&&I!==y){g[I===-1?"max":"min"].push($),E=!0;break}y=I}_=$}E||(g.min.shift(),g.max.shift())}else g.min.shift(),g.max.shift();if(g.min.length>3&&g.min.shift(),g.max.length>3&&g.max.shift(),h){if(g.min.length<1&&g.max.length<1||p>a-n){if(h.min.length>2&&h.max.length>2){o.push(NaN,NaN);for(let _=0;_<h.min.length;_+=2)o.push(h.min[_],h.min[_+1]);e==="linear-horizontal"?(o.push(h.min[h.min.length-2],l[1]),o.push(h.max[h.max.length-2],l[1])):(o.push(l[0],h.min[h.min.length-1]),o.push(l[0],h.max[h.max.length-1]));for(let _=h.max.length-2;_>=0;_-=2)o.push(h.max[_],h.max[_+1]);o.push(NaN,NaN)}o.push(l[0],l[1]),h=null}}else if(g.min.length>=1&&g.max.length>=1){const _=g.min[g.min.length-1],y=g.max[g.max.length-1],E=Math.min(_[f],y[f]);h={min:e==="linear-horizontal"?[_[u],E]:[E,_[u]],max:e==="linear-horizontal"?[y[u],E]:[E,y[u]]}}}return o.push(c[0],c[1]),o},Q=(t,e,s,i,a,n)=>{const r=[];for(let o=i;o<a;o+=n){const[l,m]=v(t,e,o);r.push(l,m)}return r},W=(t,e,s,i,a,n)=>{const r=S((a-i)/(a*n)),o=[],l=[],m=[];for(let d=0;d<r;d++){const[,x]=v(t,e,d*n);l.push(x),m.push(0)}self.fft(l,m);const c=2/r,f=c/(2*n),u=Math.max(1,~~(r/s[0][2]));for(let d=0;d<r/2;d++){let x=d,N=0;for(;d-x<u;d++)N=Math.max(N,c*Math.sqrt(l[d]**2+m[d]**2));o.push(f*(x+d+1)/2,N)}return o},K=(t,e,s,i,a,n)=>{const r=S((a-i)/n),o=[],l=[],m=[];for(let c=0;c<r;c++){const[,f]=v(t,e,c);l.push(0),m.push(f)}self.fft(l,m);for(let c=0;c*n<a&&c<l.length;c++)o.push(c*n,l[c]);return o},v=(t,e,s)=>{if(self._state.call=0,self._state.n=s,e==="parametric"){const i=t[0](s),a=t[1](s);return[i,a]}else if(e==="polar"){const i=t[0](s);return[i*Math.cos(s),i*Math.sin(s)]}else{if(e==="linear-horizontal")return[t[0](s),s];{const i=t[0](s);return[s,i]}}},Y=["line","dot","point"],O={};onmessage=({data:{index:t,region:e,affects:s,funs:i,type:a,min:n,max:r,samples:o,mode:l,rendering:m,recs:c,job:f,uuid:u}})=>{let d="",x=[],N,R;try{if(a==="unknown")throw new Error(`Invalid function type ${i.join(", ")}`);if(!Y.includes(l))throw new Error(`Invalid mode: ${l}, must be one of ${Y.join(", ")}`);typeof n=="string"&&(n=new Function("return "+n)()),typeof r=="string"&&(r=new Function("return "+r)()),typeof o=="string"&&(o=new Function("return "+o)());const h=(r-n)/o;if(isNaN(h)||h===0)throw new Error(`Invalid step ${h}`);m||(["linear","linear-horizontal"].includes(a)?m="auto":m="size");for(let w=0;w<s.length;w++){const[p,z]=s[w],P=new Function("","return "+z)();O[p]=self[p],self[p]=P}c&&Object.entries(c).forEach(([w,p])=>{!p||(self[`$rec${w}`]=z=>{const P=~~Math.round(z*p.sampleRate);return P>=0&&P<p.buffer.length?p.buffer[P]:0})}),self._state={call:0,min:n,max:r,step:h};const g=i.map(w=>new Function(D[a],"return "+w));if(f==="check"){self._state.call=self._state.n=0;const w=g[0](Math.random()*(r-n)+n);if(typeof w!="number"){let p;throw typeof w=="function"?p=new Error(self.__doc__[w]||"Function not supported"):typeof w>"u"?p=new Error(`${i[0]} is undefined`):p=new Error(`${typeof w} is not a number`),p}a==="sound"?m==="fft"?N=[[0,o/r/2,e[0][2]],[0,1,e[1][2]]]:N=[[0,r,e[0][2]],[-1,1,e[1][2]]]:N=[[-2,2,e[0][2]],[-2*e[1][2]/e[0][2],2*e[1][2]/e[0][2],e[1][2]]]}else if(f==="sound"){R=new Float32Array((r-n)/h);let w=0;if(m==="ifft"){x=K(g,a,e,n,r,h);for(let p=1;p<x.length;p+=2)R[w++]=x[p]}else for(let p=n;p<r;p+=h)self._state.call=0,self._state.n=p,R[w++]=g[0](p)}else m==="size"?x=Q(g,a,e,n,r,h):m==="adaptative"?x=H(g,a,e,n,r,h):m==="auto"?x=J(g,a,e,n,r,h):m==="fft"?x=W(g,a,e,n,r,h):m==="ifft"&&(x=K(g,a,e,n,r,h)),R=new Float32Array(x);c&&Object.keys(c).forEach(w=>{delete self[`$rec${w}`]});for(let w=0;w<s.length;w++){const[p]=s[w];self[p]=O[p],delete O[p]}}catch(h){d=h}postMessage({index:t,values:R,type:a,mode:l,max:r,samples:o,rendering:m,preferredRegion:N,err:d,uuid:u},R==null?void 0:R.buffer)}})();

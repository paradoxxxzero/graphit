(function(){"use strict";var U={sound:{adsr:"adsr usage: (x, attack = 0.2, decay = 0.1, sustain = 0.4, release = 0.3, sustainLevel = 0.5, duration = <sound duration>)",osc:"osc usage: (freq, type = sine|square|smoothsquare|sawtooth|triangle|noise, smooth = 0.5)",oscs:"oscs usage: (freqs, type = sine|square|smoothsquare|sawtooth|triangle|noise, smooth = 0.5)",sine:"sine usage: (freq)",square:"square usage: (freq)",smoothsquare:"smoothsquare usage: (freq, smooth = 0.5)",sawtooth:"sawtooth usage: (freq)",triangle:"triangle usage: (freq)",noise:"noise usage: ()",lowpass:"lowpass usage: (x, cutoff)",highpass:"highpass usage: (x, cutoff)",segment:"segment usage: (x, ...pairs)",at:"at usage: (d, f, x)"},math:{abs:"Returns the absolute value of x.",acos:"Returns the arccosine of x.",acosh:"Returns the hyperbolic arccosine of x.",asin:"Returns the arcsine of x.",asinh:"Returns the hyperbolic arcsine of a number.",atan:"Returns the arctangent of x.",atanh:"Returns the hyperbolic arctangent of x.",atan2:"Returns the arctangent of the quotient of its arguments.",cbrt:"Returns the cube root of x.",ceil:"Returns the smallest integer greater than or equal to x.",clz32:"Returns the number of leading zero bits of the 32-bit integer x.",cos:"Returns the cosine of x.",cosh:"Returns the hyperbolic cosine of x.",exp:"Returns ex, where x is the argument, and e is Euler's constant (2.718\u2026, the base of the natural logarithm).",expm1:"Returns subtracting 1 from exp(x).",floor:"Returns the largest integer less than or equal to x.",fround:"Returns the nearest single precision float representation of x.",hypot:"Returns the square root of the sum of squares of its arguments.",imul:"Returns the result of the 32-bit integer multiplication of x and y.",log:"Returns the natural logarithm (\u33D2e; also, \u33D1) of x.",log1p:"Returns the natural logarithm (\u33D2e; also \u33D1) of 1 + x for the number x.",log10:"Returns the base-10 logarithm of x.",log2:"Returns the base-2 logarithm of x.",max:"Returns the largest of zero or more numbers.",min:"Returns the smallest of zero or more numbers.",pow:"Returns base x to the exponent power y (that is, xy).",random:"Returns a pseudo-random number between 0 and 1.",round:"Returns the value of the number x rounded to the nearest integer.",sign:"Returns the sign of the x, indicating whether x is positive, negative, or zero.",sin:"Returns the sine of x.",sinh:"Returns the hyperbolic sine of x.",sqrt:"Returns the positive square root of x.",tan:"Returns the tangent of x.",tanh:"Returns the hyperbolic tangent of x.",trunc:"Returns the integer portion of x, removing any fractional digits."},constant:{e:"Euler's constant and the base of natural logarithms; approximately 2.718.",ln2:"Natural logarithm of 2; approximately 0.693.",ln10:"Natural logarithm of 10; approximately 2.303.",log2e:"Base-2 logarithm of E; approximately 1.443.",log10e:"Base-10 logarithm of E; approximately 0.434.",pi:"Ratio of a circle's circumference to its diameter; approximately 3.14159.",sqrt1_2:"Square root of \xBD; approximately 0.707.",sqrt2:"Square root of 2; approximately 1.414."},util:{lerp:"lerp usage: (x, y, a)",clamp:"clamp usage: (x, min, max)"},graphit:{"@size":"Plot each pixel","@adaptative":"Adaptative plot","@auto":"Better adaptative plot","@!":"Precision","@/dot":"Dot plot mode","@/point":"Point plot mode","@/line":"Line plot mode","@ ":"@ x0 -> x1 : Plot range [x0;x1]"}};const C={linear:"x","linear-horizontal":"y",polar:"o",parametric:"t"};self.lerp=(e,s,t)=>e+(s-e)*t,self.clamp=(e,s,t)=>Math.min(Math.max(e,s),t);for(let e of Array.from(Object.getOwnPropertyNames(Math)))self[e.toLowerCase()]=self[e]=Math[e];const I=self.PI,O=self.tau=self.TAU=I*2;self.eta=self.ETA=I/2,self.ln=self.log,self.osc=(e,s="sine",t=.5)=>{const n=++self._state.call;self._state[n]||(self._state[n]={f:0});const a=self._state[n],c=1/self._state.sampleRate,u=a.f+=self.clamp(e,0,22050)*c;switch(s){case"sine":return Math.sin(u*O);case"square":return Math.sign(Math.sin(u*O));case"smoothsquare":return Math.tanh(Math.sin(u*O)/t);case"sawtooth":return u%1*2-1;case"triangle":return Math.abs(u%1*4-2)-1;case"noise":return Math.random()*2-1;default:throw new Error(`Unknown oscillator type: ${s}`)}},self.sine=e=>self.osc(e,"sine"),self.square=e=>self.osc(e,"square"),self.smoothsquare=(e,s=.5)=>self.osc(e,"smoothsquare",s),self.sawtooth=e=>self.osc(e,"sawtooth"),self.triangle=e=>self.osc(e,"triangle"),self.noise=()=>self.osc(0,"noise"),self.oscs=(e,s,t=.5)=>{let n=0;e=Array.isArray(e)?e:[e];for(let a=0;a<e.length;a++)n+=self.osc(e[a],s,t);return n/e.length},self.adsr=(e,s=.2,t=.1,n=.4,a=.3,c=.5,u=null)=>(u=u||self._state.duration,e=e/u,e<0?0:e<=s?e/s:e<=s+t?1-(1-c)*(e-s)/t:e<=s+t+n?c:e<=s+t+n+a?c-(c-0)*(e-s-t-n)/a:0),self.lowpass=(e,s)=>{const t=++self._state.call;if(!self._state[t]){const n=1/(2*Math.PI*s),a=1/self._state.sampleRate;self._state[t]={alpha:a/(n+a),last_y:0}}return self._state[t].last_y=self._state[t].last_y+self._state[t].alpha*(e-self._state[t].last_y)},self.highpass=(e,s)=>{const t=++self._state.call;if(!self._state[t]){const n=1/(2*Math.PI*s),a=1/self._state.sampleRate;self._state[t]={alpha:n/(n+a),last_x:0,last_y:0}}return self._state[t].last_y=self._state[t].alpha*(self._state[t].last_y+e-self._state[t].last_x),self._state[t].last_x=e,self._state[t].last_y},self.segment=(e,...s)=>{for(let t=0;t<s.length;t+=2)if(e<s[t])return s[t+1]},self.at=(e,s,t)=>s(t+e),self.__doc__=Object.fromEntries(Object.entries(U).map(([e,s])=>Object.entries(s).map(([t,n])=>[self[t],`${e}: ${n}`])).flat());const q={epsilon:1e-9,sampling:1500,subsampling:32,minBlockSize:10,precisionPass:8,precision:I/1024,extremumPass:32,straightness:1e-5,maxPoints:1e4,overflow:.1},T=(e,s,t,n,a)=>{var c,u;if(isNaN(s)||isNaN(t)||s<n[0][0]||s>n[0][1]||t<n[1][0]||t>n[1][1]){(c=e.out)!=null&&c.length||e.length>0&&e.push(s,t),e.out=[s,t];return}(u=e.out)!=null&&u.length&&(a==="linear-horizontal"?e.push(NaN,((e[e.length-1]||n[1][0])+e.out[1])/2):a==="linear"?e.push(((e[e.length-2]||n[0][0])+e.out[0])/2,NaN):e.push(NaN,NaN),e.push(...e.out),e.out.splice(0)),e.push(s,t)},D=(e,s,t,n,a,c,u,f)=>{if(t==="linear"){const i=f*n+(1-f)*c,p=s[0](i);e(i,p)}else if(t==="linear-horizontal"){const i=f*a+(1-f)*u,p=s[0](i);e(p,i)}},L=(e,s,t,n,a)=>{const[[c,u],[f,i]]=n,p=[],g=(N,w)=>T(p,N,w,n,t),b=(N,w,z,o,r)=>D(g,s,t,N,w,z,o,r),l=(i-f)/(u-c);let R=0;for(let N=0;N+R<e.length;N+=4){const w=e[N],z=e[N+1],o=e[N+2+R],r=e[N+3+R],P=e[N+4+R],x=e[N+5+R];if(t==="linear"&&(isNaN(z)||isNaN(r)||isNaN(x))||t==="linear-horizontal"&&(isNaN(w)||isNaN(o)||isNaN(P))){N+=R,R=0,g(w,z),g(o,r);continue}const m=Math.atan2(r-z,l*(o-w)),h=Math.atan2(x-r,l*(P-o))-m,d=Math.abs(h),G=((P-w)/(u-c))**2+((x-z)/(i-f))**2;if(d*G<q.straightness){N-=4,R+=2;continue}if(R&&(N+=R,R=0),a){g(w,z),g(o,r);continue}const A=d>q.precision;g(w,z),A&&b(w,z,o,r,1/2),g(o,r),A&&b(o,r,P,x,1/2)}return p},V=(e,s,t,n)=>{for(let a=2;a<e.length-2;a+=2){let c=e[a-2],u=e[a-1],f=e[a],i=e[a+1],p=e[a+2],g=e[a+3];const b=n[t==="linear-horizontal"?0:1];if(t==="linear-horizontal"&&([c,u]=[u,c],[f,i]=[i,f],[p,g]=[g,p]),isNaN(i)||isNaN(g)||isNaN(u))continue;const l=Math.sign(i-u),R=Math.sign(g-i);if(l!==R){let N=c,w=f,z=p,o=i;for(let r=0;r<q.extremumPass;r++){const P=(N+w)/2,x=s[0](P),m=(w+z)/2,_=s[0](m);if(Math.sign(x-o)===l?(z=w,w=P,o=x):Math.sign(_-o)===l?(N=w,w=m,o=_):(N=P,z=m),N===z||o>b[1]||o<b[0])break}e[a]=w,e[a+1]=o,t==="linear-horizontal"&&([e[a],e[a+1]]=[e[a+1],e[a]])}}},X=(e,s,t,n,a,c)=>{let u=[];for(let f=n;f<a;f+=c){const[i,p]=E(e,s,f);T(u,i,p,t,s)}u=L(u,e,s,t,!0),V(u,e,s,t);for(let f=0;f<q.precisionPass&&!(u.length>q.maxPoints);f++)u=L(u,e,s,t);return u},H=(e,s,t,n,a,c)=>{const u=a-n;n-=u*q.overflow/2,a+=u*q.overflow/2;const f=[];let i=[NaN,NaN],p=[NaN,NaN],g=E(e,s,n);const[b,l]=s==="linear-horizontal"?[1,0]:[0,1],R=t[s==="linear-horizontal"?0:1],N=t[s==="linear-horizontal"?1:0],w=(R[1]-R[0])/(N[1]-N[0]),z=(N[1]-N[0])*q.epsilon;let o=null,r={min:[],max:[]},P=!1;for(let x=n;x<=a;x+=c){if(p=i,i=g,g=E(e,s,x+c),isNaN(i[l])||isNaN(g[l])){f.push(i[0],i[1]);continue}if(!isNaN(p[l])&&!o&&x<a-c){const M=Math.atan2(i[l]-p[l],w*(i[b]-p[b])),y=Math.atan2(g[l]-i[l],w*(g[b]-i[b]))-M,$=Math.abs(y),k=((g[b]-p[b])/(N[1]-N[0]))**2+((g[l]-p[l])/(R[1]-R[0]))**2;if($*k<q.straightness){P=!0,i=p;continue}else P&&(P=!1,x-=c,g=i,i=p)}o||f.push(i[0],i[1]);let m=i[b],_=g[b],h=E(e,s,m+(_-m)/3),d=E(e,s,_-(_-m)/3);const G=Math.sign(h[l]-i[l]),A=Math.sign(d[l]-h[l]),j=Math.sign(g[l]-d[l]),F=j===-1?"max":"min";if(G!==A||A!==j)for(let M=0;M<q.extremumPass;M++){if(h[l]>R[1]&&d[l]<R[0]||h[l]<R[0]&&d[l]>R[1]){const v=E(e,s,(m+_)/2),y=Math.sign(v[l]-h[l]),$=Math.sign(d[l]-v[l]);if(y!==$){h[l]>d[l]?(r.max.push(h),r.min.push(d)):(r.max.push(d),r.min.push(h)),o?h[l]>d[l]?(o.max.push(h[0],h[1]),o.min.push(d[0],d[1])):(o.max.push(d[0],d[1]),o.min.push(h[0],h[1])):(f.push(h[0],h[1]),s==="linear-horizontal"?f.push(NaN,(h[1]+d[1])/2):f.push((h[0]+d[0])/2,NaN),f.push(d[0],d[1]));break}}if(j===-1?h[l]<d[l]?m=h[b]:_=d[b]:h[l]>d[l]?m=h[b]:_=d[b],Math.abs(_-m)<z||M===q.extremumPass-1){j===-1&&h[l]>d[l]||j===1&&h[l]<d[l]?(r[F].push(h),o?o[F].push(h[0],h[1]):f.push(h[0],h[1])):(r[F].push(d),o?o[F].push(d[0],d[1]):f.push(d[0],d[1]));break}h=E(e,s,m+(_-m)/3),d=E(e,s,_-(_-m)/3)}else if(r.max.length+r.min.length>0){let M=null,v=0,y=!1;for(let $=0;$<=q.subsampling;$++){let k=$===0?i:$===q.subsampling?g:E(e,s,((q.subsampling-$)*i[b]+$*g[b])/q.subsampling);if(M){const S=Math.sign(k[l]-M[l]);if(v&&S!==v){r[S===-1?"max":"min"].push(k),y=!0;break}v=S}M=k}y||(r.min.shift(),r.max.shift())}else r.min.shift(),r.max.shift();if(r.min.length>3&&r.min.shift(),r.max.length>3&&r.max.shift(),o){if(r.min.length<1&&r.max.length<1||x>a-c){if(o.min.length>2&&o.max.length>2){f.push(NaN,NaN);for(let M=0;M<o.min.length;M+=2)f.push(o.min[M],o.min[M+1]);s==="linear-horizontal"?(f.push(o.min[o.min.length-2],i[1]),f.push(o.max[o.max.length-2],i[1])):(f.push(i[0],o.min[o.min.length-1]),f.push(i[0],o.max[o.max.length-1]));for(let M=o.max.length-2;M>=0;M-=2)f.push(o.max[M],o.max[M+1]);f.push(NaN,NaN)}f.push(i[0],i[1]),o=null}}else if(r.min.length>=1&&r.max.length>=1){const M=r.min[r.min.length-1],v=r.max[r.max.length-1],y=Math.min(M[b],v[b]);o={min:s==="linear-horizontal"?[M[l],y]:[y,M[l]],max:s==="linear-horizontal"?[v[l],y]:[y,v[l]]}}}return f.push(g[0],g[1]),f},J=(e,s,t,n,a,c)=>{const u=[];for(let f=n;f<a;f+=c){const[i,p]=E(e,s,f);T(u,i,p,t,s)}return u},E=(e,s,t)=>{if(self._state.call=0,s==="parametric"){const n=e[0](t),a=e[1](t);return[n,a]}else if(s==="polar"){const n=e[0](t);return[n*Math.cos(t),n*Math.sin(t)]}else{if(s==="linear-horizontal")return[e[0](t),t];if(s==="linear"){const n=e[0](t);return[t,n]}}throw new Error(`Unknown plot type ${s}`)},Y=["line","dot","point"],B={};onmessage=({data:{index:e,funs:s,type:t,min:n,max:a,samples:c,region:u,affects:f,mode:i,rendering:p,recs:g,dimensions:b=2,sampleRate:l,duration:R,uuid:N}})=>{let w="",z=[],o;try{if(t==="unknown")throw new Error(`Invalid function type ${s.join(", ")}`);if(!Y.includes(i))throw new Error(`Invalid mode: ${i}, must be one of ${Y.join(", ")}`);typeof n=="string"&&(n=new Function("return "+n)()),typeof a=="string"&&(a=new Function("return "+a)()),typeof c=="string"&&(c=new Function("return "+c)());const r=(a-n)/c;if(isNaN(r)||r===0)throw new Error(`Invalid step ${r}`);p||(["linear","linear-horizontal"].includes(t)&&!Object.keys(U.sound).some(x=>s[0].match(new RegExp(`\\b${x}\\b`)))?p="auto":p="size");for(let x=0;x<f.length;x++){const[m,_]=f[x],h=new Function("","return "+_)();B[m]=self[m],self[m]=h}g&&Object.entries(g).forEach(([x,m])=>{!m||(self[`$rec${x}`]=_=>{const h=~~Math.round(_*m.sampleRate);return h>=0&&h<m.buffer.length?m.buffer[h]:0})}),self._state={sampleRate:l,duration:R,call:0};const P=s.map(x=>new Function(C[t],"return "+x));if(b===1){o=new Float32Array((a-n)/r);let x=0;for(let m=n;m<a;m+=r){self._state.call=0;const _=P[0](m);if(typeof _!="number"){let h;throw typeof _=="function"?h=new Error(self.__doc__[_]||"Function not supported"):typeof _>"u"?h=new Error(`${s[0]} is undefined`):h=new Error(`${typeof _} is not a number`),h}o[x++]=_}}else b===2&&(p==="size"?z=J(P,t,u,n,a,r):p==="adaptative"?z=X(P,t,u,n,a,r):p==="auto"&&(z=H(P,t,u,n,a,r)),o=new Float32Array(z));g&&Object.keys(g).forEach(x=>{delete self[`$rec${x}`]});for(let x=0;x<f.length;x++){const[m]=f[x];self[m]=B[m],delete B[m]}}catch(r){w=r}postMessage({index:e,values:o,type:t,mode:i,err:w,uuid:N},o==null?void 0:o.buffer)}})();

(function(){"use strict";const $={linear:"x","linear-horizontal":"y",polar:"o",parametric:"t"};for(let e of Array.from(Object.getOwnPropertyNames(Math)))self[e.toLowerCase()]=self[e]=Math[e];const y=self.PI;self.tau=self.TAU=self.PI*2;const F=self.eta=self.ETA=self.PI/2;self.ln=self.log,self.osc=(e,n,s="sine")=>n<0?0:s==="sine"?Math.sin(2*Math.PI*e*n):s==="square"?Math.sign(Math.sin(2*Math.PI*e*n)):s==="sawtooth"?2*(n*e-~~(n*e+.5)):s==="triangle"?2*Math.abs(2*(n*e+.25-~~(n*e+.75)))-1:0,self.adsr=(e,n=.2,s=.1,l=.4,c=.3,b=.5)=>e<0?0:e<=n?e/n:e<=n+s?1-(1-b)*(e-n)/s:e<=n+s+l?b:e<=n+s+l+c?b-(b-0)*(e-n-s-l)/c:0,self.__doc__={[self.adsr]:"adsr usage: (x, attack = 0.2, decay = 0.1, sustain = 0.4, release = 0.3, sustainLevel = 0.5)",[self.osc]:"osc usage: (freq, x, type = sine|square|sawtooth|triangle)",[self.abs]:"Returns the absolute value of x.",[self.acos]:"Returns the arccosine of x.",[self.acosh]:"Returns the hyperbolic arccosine of x.",[self.asin]:"Returns the arcsine of x.",[self.asinh]:"Returns the hyperbolic arcsine of a number.",[self.atan]:"Returns the arctangent of x.",[self.atanh]:"Returns the hyperbolic arctangent of x.",[self.atan2]:"Returns the arctangent of the quotient of its arguments.",[self.cbrt]:"Returns the cube root of x.",[self.ceil]:"Returns the smallest integer greater than or equal to x.",[self.clz32]:"Returns the number of leading zero bits of the 32-bit integer x.",[self.cos]:"Returns the cosine of x.",[self.cosh]:"Returns the hyperbolic cosine of x.",[self.exp]:"Returns ex, where x is the argument, and e is Euler's constant (2.718\u2026, the base of the natural logarithm).",[self.expm1]:"Returns subtracting 1 from exp(x).",[self.floor]:"Returns the largest integer less than or equal to x.",[self.fround]:"Returns the nearest single precision float representation of x.",[self.hypot]:"Returns the square root of the sum of squares of its arguments.",[self.imul]:"Returns the result of the 32-bit integer multiplication of x and y.",[self.log]:"Returns the natural logarithm (\u33D2e; also, \u33D1) of x.",[self.log1p]:"Returns the natural logarithm (\u33D2e; also \u33D1) of 1 + x for the number x.",[self.log10]:"Returns the base-10 logarithm of x.",[self.log2]:"Returns the base-2 logarithm of x.",[self.max]:"Returns the largest of zero or more numbers.",[self.min]:"Returns the smallest of zero or more numbers.",[self.pow]:"Returns base x to the exponent power y (that is, xy).",[self.random]:"Returns a pseudo-random number between 0 and 1.",[self.round]:"Returns the value of the number x rounded to the nearest integer.",[self.sign]:"Returns the sign of the x, indicating whether x is positive, negative, or zero.",[self.sin]:"Returns the sine of x.",[self.sinh]:"Returns the hyperbolic sine of x.",[self.sqrt]:"Returns the positive square root of x.",[self.tan]:"Returns the tangent of x.",[self.tanh]:"Returns the hyperbolic tangent of x.",[self.trunc]:"Returns the integer portion of x, removing any fractional digits."};const P={sampling:1e3,precisionPass:16,precision:y/1024,straightness:y/5e3,supplenessPrecision:F/2,suppleness:y/2e3,maxPoints:1e4},v=(e,n,s,l,c)=>{var b,m;if(isNaN(n)||isNaN(s)||n<l[0][0]||n>l[0][1]||s<l[1][0]||s>l[1][1]){(!((b=e.out)!=null&&b.length)||(isNaN(n)||isNaN(s))&&!isNaN(e.out[0])&&!isNaN(e.out[1]))&&e.push(n,s),e.out=[n,s];return}(m=e.out)!=null&&m.length&&(e.length>1&&(c==="linear-horizontal"?e.push(NaN,e[e.length-1]):c==="linear"&&e.push(e[e.length-2],NaN)),e.push(...e.out),e.out.splice(0)),e.push(n,s)},_=(e,n,s,l)=>{const[[c,b],[m,x]]=l,M=[],a=(i,f)=>v(M,i,f,l,s),h=(i,f,u,o,g)=>{if(s==="linear"){const t=g*i+(1-g)*u,r=n[0](t);a(t,r)}else if(s==="linear-horizontal"){const t=g*f+(1-g)*o,r=n[0](t);a(r,t)}},w=(x-m)/(b-c);let d;for(d=0;d<e.length-6;d+=4){const i=e[d],f=e[d+1],u=e[d+2],o=e[d+3],g=e[d+4],t=e[d+5];if(isNaN(f)){a(i,f),h(i,f,u,o,3/4),a(u,o);continue}if(isNaN(o)){a(i,f),h(i,f,u,o,1/4),a(u,o),h(u,o,g,t,3/4);continue}if(isNaN(t)){a(i,f),a(u,o),h(u,o,g,t,1/4);continue}const r=Math.atan2(o-f,w*(u-i)),R=Math.atan2(t-o,w*(g-u))-r,A=Math.abs(R),I=A>P.precision;if(A>P.supplenessPrecision&&(r>self.eta-P.suppleness||r<-self.eta+P.suppleness)){a(u,o),h(u,o,g,t,3/4),h(u,o,g,t,1/4);continue}a(i,f),I&&h(i,f,u,o,1/2),a(u,o),I&&h(u,o,g,t,1/2)}for(let i=d;i<e.length;i+=2)a(e[i],e[i+1]);return M},E=(e,n,s)=>{const[[l,c],[b,m]]=s,x=[],M=(m-b)/(c-l);let a,h=0;for(a=0;a+h<e.length;a+=2){const w=e[a],d=e[a+1],i=e[a+2+h],f=e[a+3+h],u=e[a+4+h],o=e[a+5+h];if(n==="linear"&&(isNaN(d)||isNaN(f)||isNaN(o))||n==="linear-horizontal"&&(isNaN(w)||isNaN(i)||isNaN(u))){a+=h,h=0,x.push(w,d);continue}const g=Math.atan2(f-d,M*(i-w)),r=Math.atan2(o-f,M*(u-i))-g,N=Math.sqrt(((u-w)/(c-l))**2+((o-d)/(m-b))**2);Math.abs(r)*N<P.straightness?(a-=2,h+=2):(x.push(w,d),a+=h,h=0)}return x},j=(e,n,s,l)=>{e=E(e,s,l);for(let c=0;c<P.precisionPass&&!(e.length>P.maxPoints);c++)e=_(e,n,s,l);return e=E(e,s,l),e},z=["line","dot","point"],p={};onmessage=({data:{index:e,funs:n,type:s,min:l,max:c,samples:b,region:m,affects:x,mode:M,recs:a,dimensions:h=2,uuid:w}})=>{let d="",i=[],f,u=!1;try{if(s==="unknown")throw new Error(`Invalid function type ${n.join(", ")}`);if(!z.includes(M))throw new Error(`Invalid mode: ${M}, must be one of ${z.join(", ")}`);typeof l=="string"&&(l=new Function("return "+l)()),typeof c=="string"&&(c=new Function("return "+c)()),typeof b=="string"&&(b==="auto"?(u=!0,b=P.sampling):b=new Function("return "+b)());const o=(c-l)/b;if(isNaN(o)||o<1e-9)throw new Error(`Invalid step ${o}`);for(let t=0;t<x.length;t++){const[r,N]=x[t],R=new Function("","return "+N)();p[r]=self[r],self[r]=R}a&&Object.entries(a).forEach(([t,r])=>{!r||(self[`$rec${t}`]=N=>{const R=~~Math.round(N*r.sampleRate);return R>=0&&R<r.buffer.length?r.buffer[R]:0})});const g=n.map(t=>new Function($[s],"return "+t));if(h===1){f=new Float32Array((c-l)/o);let t=0;for(let r=l;r<c;r+=o){const N=g[0](r);if(typeof N!="number"){let R;throw typeof N=="function"?R=new Error(self.__doc__[N]||"Function not supported"):typeof N>"u"?R=new Error(`${n[0]} is undefined`):R=new Error(`${typeof N} is not a number`),R}f[t++]=N}}else if(h===2){for(let t=l;t<c;t+=o){let r,N;if(s==="parametric")r=g[0](t),N=g[1](t);else if(s==="polar"){const R=g[0](t);r=R*Math.cos(t),N=R*Math.sin(t)}else s==="linear-horizontal"?(r=g[0](t),N=t):(r=t,N=g[0](t));v(i,r,N,m,s)}u&&(i=new Float32Array(j(i,g,s,m))),f=new Float32Array(i)}a&&Object.keys(a).forEach(t=>{delete self[`$rec${t}`]});for(let t=0;t<x.length;t++){const[r]=x[t];self[r]=p[r],delete p[r]}}catch(o){d=o}postMessage({index:e,values:f,type:s,mode:M,err:d,uuid:w},f==null?void 0:f.buffer)}})();

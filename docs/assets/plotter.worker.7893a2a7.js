(function(){"use strict";const q={linear:"x","linear-horizontal":"y",polar:"o",parametric:"t"};for(let e of Array.from(Object.getOwnPropertyNames(Math)))self[e.toLowerCase()]=self[e]=Math[e];const k=self.PI;self.tau=self.TAU=self.PI*2,self.eta=self.ETA=self.PI/2,self.ln=self.log,self.osc=(e,t,n="sine")=>t<0?0:n==="sine"?Math.sin(2*Math.PI*e*t):n==="square"?Math.sign(Math.sin(2*Math.PI*e*t)):n==="sawtooth"?2*(t*e-~~(t*e+.5)):n==="triangle"?2*Math.abs(2*(t*e+.25-~~(t*e+.75)))-1:0,self.adsr=(e,t=.2,n=.1,i=.4,o=.3,b=.5)=>e<0?0:e<=t?e/t:e<=t+n?1-(1-b)*(e-t)/n:e<=t+n+i?b:e<=t+n+i+o?b-(b-0)*(e-t-n-i)/o:0,self.__doc__={[self.adsr]:"adsr usage: (x, attack = 0.2, decay = 0.1, sustain = 0.4, release = 0.3, sustainLevel = 0.5)",[self.osc]:"osc usage: (freq, x, type = sine|square|sawtooth|triangle)",[self.abs]:"Returns the absolute value of x.",[self.acos]:"Returns the arccosine of x.",[self.acosh]:"Returns the hyperbolic arccosine of x.",[self.asin]:"Returns the arcsine of x.",[self.asinh]:"Returns the hyperbolic arcsine of a number.",[self.atan]:"Returns the arctangent of x.",[self.atanh]:"Returns the hyperbolic arctangent of x.",[self.atan2]:"Returns the arctangent of the quotient of its arguments.",[self.cbrt]:"Returns the cube root of x.",[self.ceil]:"Returns the smallest integer greater than or equal to x.",[self.clz32]:"Returns the number of leading zero bits of the 32-bit integer x.",[self.cos]:"Returns the cosine of x.",[self.cosh]:"Returns the hyperbolic cosine of x.",[self.exp]:"Returns ex, where x is the argument, and e is Euler's constant (2.718\u2026, the base of the natural logarithm).",[self.expm1]:"Returns subtracting 1 from exp(x).",[self.floor]:"Returns the largest integer less than or equal to x.",[self.fround]:"Returns the nearest single precision float representation of x.",[self.hypot]:"Returns the square root of the sum of squares of its arguments.",[self.imul]:"Returns the result of the 32-bit integer multiplication of x and y.",[self.log]:"Returns the natural logarithm (\u33D2e; also, \u33D1) of x.",[self.log1p]:"Returns the natural logarithm (\u33D2e; also \u33D1) of 1 + x for the number x.",[self.log10]:"Returns the base-10 logarithm of x.",[self.log2]:"Returns the base-2 logarithm of x.",[self.max]:"Returns the largest of zero or more numbers.",[self.min]:"Returns the smallest of zero or more numbers.",[self.pow]:"Returns base x to the exponent power y (that is, xy).",[self.random]:"Returns a pseudo-random number between 0 and 1.",[self.round]:"Returns the value of the number x rounded to the nearest integer.",[self.sign]:"Returns the sign of the x, indicating whether x is positive, negative, or zero.",[self.sin]:"Returns the sine of x.",[self.sinh]:"Returns the hyperbolic sine of x.",[self.sqrt]:"Returns the positive square root of x.",[self.tan]:"Returns the tangent of x.",[self.tanh]:"Returns the hyperbolic tangent of x.",[self.trunc]:"Returns the integer portion of x, removing any fractional digits."};const P={epsilon:1e-9,sampling:1500,subsampling:2,minBlockSize:10,precisionPass:8,precision:k/1024,extremumPass:32,straightness:1e-5,maxPoints:1e4},_=(e,t,n,i,o)=>{var b,a;if(isNaN(t)||isNaN(n)||t<i[0][0]||t>i[0][1]||n<i[1][0]||n>i[1][1]){(b=e.out)!=null&&b.length||e.length>0&&e.push(t,n),e.out=[t,n];return}(a=e.out)!=null&&a.length&&(o==="linear-horizontal"?e.push(NaN,((e[e.length-1]||i[1][0])+e.out[1])/2):o==="linear"?e.push(((e[e.length-2]||i[0][0])+e.out[0])/2,NaN):e.push(NaN,NaN),e.push(...e.out),e.out.splice(0)),e.push(t,n)},O=(e,t,n,i,o,b,a,s)=>{if(n==="linear"){const u=s*i+(1-s)*b,c=t[0](u);e(u,c)}else if(n==="linear-horizontal"){const u=s*o+(1-s)*a,c=t[0](u);e(c,u)}},j=(e,t,n,i,o)=>{const[[b,a],[s,u]]=i,c=[],N=(d,x)=>_(c,d,x,i,n),l=(d,x,m,R,r)=>O(N,t,n,d,x,m,R,r),M=(u-s)/(a-b);let w=0;for(let d=0;d+w<e.length;d+=4){const x=e[d],m=e[d+1],R=e[d+2+w],r=e[d+3+w],f=e[d+4+w],h=e[d+5+w];if(n==="linear"&&(isNaN(m)||isNaN(r)||isNaN(h))||n==="linear-horizontal"&&(isNaN(x)||isNaN(R)||isNaN(f))){d+=w,w=0,N(x,m),N(R,r);continue}const g=Math.atan2(r-m,M*(R-x)),A=Math.atan2(h-r,M*(f-R))-g,I=Math.abs(A),v=((f-x)/(a-b))**2+((h-m)/(u-s))**2;if(I*v<P.straightness){d-=4,w+=2;continue}if(w&&(d+=w,w=0),o){N(x,m),N(R,r);continue}const E=I>P.precision;N(x,m),E&&l(x,m,R,r,1/2),N(R,r),E&&l(R,r,f,h,1/2)}return c},B=(e,t,n,i)=>{for(let o=2;o<e.length-2;o+=2){let b=e[o-2],a=e[o-1],s=e[o],u=e[o+1],c=e[o+2],N=e[o+3];const l=i[n==="linear-horizontal"?0:1];if(n==="linear-horizontal"&&([b,a]=[a,b],[s,u]=[u,s],[c,N]=[N,c]),isNaN(u)||isNaN(N)||isNaN(a))continue;const M=Math.sign(u-a),w=Math.sign(N-u);if(M!==w){let d=b,x=s,m=c,R=u;for(let r=0;r<P.extremumPass;r++){const f=(d+x)/2,h=t[0](f),g=(x+m)/2,$=t[0](g);if(Math.sign(h-R)===M?(m=x,x=f,R=h):Math.sign($-R)===M?(d=x,x=g,R=$):(d=f,m=g),d===m||R>l[1]||R<l[0])break}e[o]=x,e[o+1]=R,n==="linear-horizontal"&&([e[o],e[o+1]]=[e[o+1],e[o]])}}},G=(e,t,n,i,o,b)=>{let a=[];for(let s=i;s<o;s+=b){const[u,c]=z(e,s,t);_(a,u,c,n,t)}a=j(a,e,t,n,!0),B(a,e,t,n);for(let s=0;s<P.precisionPass&&!(a.length>P.maxPoints);s++)a=j(a,e,t,n);return a},y=(e,t,n,i,o,b)=>{const a=[];let s=[NaN,NaN],u=[NaN,NaN],c=z(e,i,t);const[N,l]=t==="linear-horizontal"?[1,0]:[0,1],M=n[t==="linear-horizontal"?0:1],w=n[t==="linear-horizontal"?1:0],d=(M[1]-M[0])/(w[1]-w[0]),x=(w[1]-w[0])*P.epsilon;let m=!1;for(let R=i;R<=o;R+=b){if(s=c,c=z(e,R+b,t),isNaN(s[l])||isNaN(c[l])){a.push(s[0],s[1]),u=s;continue}if(!isNaN(u[l])&&R<o-b){const v=Math.atan2(s[l]-u[l],d*(s[N]-u[N])),U=Math.atan2(c[l]-s[l],d*(c[N]-s[N]))-v,Y=Math.abs(U),C=((c[N]-u[N])/(w[1]-w[0]))**2+((c[l]-u[l])/(M[1]-M[0]))**2;if(Y*C<P.straightness){m=!0;continue}else m&&(m=!1,a.push(u[0],u[1]))}a.push(s[0],s[1]);let r=s[N],f=c[N],h=z(e,r+(f-r)/3,t),g=z(e,f-(f-r)/3,t);const $=Math.sign(h[l]-s[l]),A=Math.sign(g[l]-h[l]),I=Math.sign(c[l]-g[l]);if($!==A||A!==I)for(let v=0;v<P.extremumPass;v++){if(h[l]>M[1]&&g[l]<M[0]||h[l]<M[0]&&g[l]>M[1]){const E=z(e,(r+f)/2,t);if(Math.sign(h[l]-E[l])===Math.sign(g[l]-E[l])){a.push(h[0],h[1]),a.push((h[0]+g[0])/2,NaN),a.push(g[0],g[1]);break}}if(I===-1?h[l]<g[l]?r=h[N]:f=g[N]:h[l]>g[l]?r=h[N]:f=g[N],Math.abs(f-r)<x||v===P.extremumPass-1){a.push(h[0],h[1]),a.push(g[0],g[1]);break}h=z(e,r+(f-r)/3,t),g=z(e,f-(f-r)/3,t)}u=s}return a.push(c[0],c[1]),a},S=(e,t,n,i,o,b)=>{const a=[];for(let s=i;s<o;s+=b){const[u,c]=z(e,s,t);_(a,u,c,n,t)}return a},z=(e,t,n)=>{if(n==="parametric")return[e[0](t),e[1](t)];if(n==="polar"){const i=e[0](t);return[i*Math.cos(t),i*Math.sin(t)]}else{if(n==="linear-horizontal")return[e[0](t),t];if(n==="linear")return[t,e[0](t)]}throw new Error(`Unknown plot type ${n}`)},T=["line","dot","point"],F={};onmessage=({data:{index:e,funs:t,type:n,min:i,max:o,samples:b,region:a,affects:s,mode:u,rendering:c,recs:N,dimensions:l=2,uuid:M}})=>{let w="",d=[],x;try{if(n==="unknown")throw new Error(`Invalid function type ${t.join(", ")}`);if(!T.includes(u))throw new Error(`Invalid mode: ${u}, must be one of ${T.join(", ")}`);typeof i=="string"&&(i=new Function("return "+i)()),typeof o=="string"&&(o=new Function("return "+o)()),typeof b=="string"&&(b=new Function("return "+b)());const m=(o-i)/b;if(isNaN(m)||m===0)throw new Error(`Invalid step ${m}`);c||(["linear","linear-horizontal"].includes(n)?c="auto":c="size");for(let r=0;r<s.length;r++){const[f,h]=s[r],g=new Function("","return "+h)();F[f]=self[f],self[f]=g}N&&Object.entries(N).forEach(([r,f])=>{!f||(self[`$rec${r}`]=h=>{const g=~~Math.round(h*f.sampleRate);return g>=0&&g<f.buffer.length?f.buffer[g]:0})});const R=t.map(r=>new Function(q[n],"return "+r));if(l===1){x=new Float32Array((o-i)/m);let r=0;for(let f=i;f<o;f+=m){const h=R[0](f);if(typeof h!="number"){let g;throw typeof h=="function"?g=new Error(self.__doc__[h]||"Function not supported"):typeof h>"u"?g=new Error(`${t[0]} is undefined`):g=new Error(`${typeof h} is not a number`),g}x[r++]=h}}else l===2&&(c==="size"?d=S(R,n,a,i,o,m):c==="adaptative"?d=G(R,n,a,i,o,m):c==="auto"&&(d=y(R,n,a,i,o,m)),x=new Float32Array(d));N&&Object.keys(N).forEach(r=>{delete self[`$rec${r}`]});for(let r=0;r<s.length;r++){const[f]=s[r];self[f]=F[f],delete F[f]}}catch(m){w=m}postMessage({index:e,values:x,type:n,mode:u,err:w,uuid:M},x==null?void 0:x.buffer)}})();

(function(){"use strict";var S={sound:{adsr:"adsr usage: (x, attack = 0.2, decay = 0.1, sustain = 0.4, release = 0.3, sustainLevel = 0.5, duration = <sound duration>)",osc:"osc usage: (x, freq, type = sine|square|smoothsquare|sawtooth|triangle|noise, smooth = 0.5)",oscs:"oscs usage: (x, freqs, type = sine|square|smoothsquare|sawtooth|triangle|noise, smooth = 0.5)",sine:"sine usage: (x, freq)",square:"square usage: (x, freq)",smoothsquare:"smoothsquare usage: (x, freq, smooth = 0.5)",sawtooth:"sawtooth usage: (x, freq)",triangle:"triangle usage: (x, freq)",noise:"noise usage: (x)",lowpass:"lowpass usage: (x, input, cutoff)",highpass:"highpass usage: (x, input, cutoff)",segment:"segment usage: (x, ...pairs)",at:"at usage: (d, f, x)"},math:{abs:"Returns the absolute value of x.",acos:"Returns the arccosine of x.",acosh:"Returns the hyperbolic arccosine of x.",asin:"Returns the arcsine of x.",asinh:"Returns the hyperbolic arcsine of a number.",atan:"Returns the arctangent of x.",atanh:"Returns the hyperbolic arctangent of x.",atan2:"Returns the arctangent of the quotient of its arguments.",cbrt:"Returns the cube root of x.",ceil:"Returns the smallest integer greater than or equal to x.",clz32:"Returns the number of leading zero bits of the 32-bit integer x.",cos:"Returns the cosine of x.",cosh:"Returns the hyperbolic cosine of x.",exp:"Returns ex, where x is the argument, and e is Euler's constant (2.718\u2026, the base of the natural logarithm).",expm1:"Returns subtracting 1 from exp(x).",floor:"Returns the largest integer less than or equal to x.",fround:"Returns the nearest single precision float representation of x.",hypot:"Returns the square root of the sum of squares of its arguments.",imul:"Returns the result of the 32-bit integer multiplication of x and y.",log:"Returns the natural logarithm (\u33D2e; also, \u33D1) of x.",log1p:"Returns the natural logarithm (\u33D2e; also \u33D1) of 1 + x for the number x.",log10:"Returns the base-10 logarithm of x.",log2:"Returns the base-2 logarithm of x.",max:"Returns the largest of zero or more numbers.",min:"Returns the smallest of zero or more numbers.",pow:"Returns base x to the exponent power y (that is, xy).",random:"Returns a pseudo-random number between 0 and 1.",round:"Returns the value of the number x rounded to the nearest integer.",sign:"Returns the sign of the x, indicating whether x is positive, negative, or zero.",sin:"Returns the sine of x.",sinh:"Returns the hyperbolic sine of x.",sqrt:"Returns the positive square root of x.",tan:"Returns the tangent of x.",tanh:"Returns the hyperbolic tangent of x.",trunc:"Returns the integer portion of x, removing any fractional digits."},constant:{e:"Euler's constant and the base of natural logarithms; approximately 2.718.",ln2:"Natural logarithm of 2; approximately 0.693.",ln10:"Natural logarithm of 10; approximately 2.303.",log2e:"Base-2 logarithm of E; approximately 1.443.",log10e:"Base-10 logarithm of E; approximately 0.434.",pi:"Ratio of a circle's circumference to its diameter; approximately 3.14159.",sqrt1_2:"Square root of \xBD; approximately 0.707.",sqrt2:"Square root of 2; approximately 1.414."},util:{lerp:"lerp usage: (x, y, a)",clamp:"clamp usage: (x, min, max)"},graphit:{"@size":"Plot each pixel","@adaptative":"Adaptative plot","@auto":"Better adaptative plot","@!":"Precision","@/dot":"Dot plot mode","@/point":"Point plot mode","@/line":"Line plot mode","@ ":"@ x0 -> x1 : Plot range [x0;x1]"}};const C={linear:"x","linear-horizontal":"y",polar:"o",parametric:"t"};self.lerp=(e,t,s)=>e+(t-e)*s,self.clamp=(e,t,s)=>Math.min(Math.max(e,t),s);for(let e of Array.from(Object.getOwnPropertyNames(Math)))self[e.toLowerCase()]=self[e]=Math[e];const I=self.PI,O=self.tau=self.TAU=I*2;self.eta=self.ETA=I/2,self.ln=self.log,self.osc=(e,t,s="sine",n=.5)=>{const a=++self._state.call;if(self._state.n<0)return 0;self._state[a]||(self._state[a]={f:0,last_x:0});const r=self._state[a],u=e-r.last_x;r.last_x=e;const o=r.f+=self.clamp(t,0,22050)*u;switch(s){case"sine":return Math.sin(o*O);case"square":return Math.sign(Math.sin(o*O));case"smoothsquare":return Math.tanh(Math.sin(o*O)/n);case"sawtooth":return o%1*2-1;case"triangle":return Math.abs(o%1*4-2)-1;case"noise":return Math.random()*2-1;default:throw new Error(`Unknown oscillator type: ${s}`)}},self.sine=(e,t)=>self.osc(e,t,"sine"),self.square=(e,t)=>self.osc(e,t,"square"),self.smoothsquare=(e,t,s=.5)=>self.osc(e,t,"smoothsquare",s),self.sawtooth=(e,t)=>self.osc(e,t,"sawtooth"),self.triangle=(e,t)=>self.osc(e,t,"triangle"),self.noise=()=>self.osc(0,"noise"),self.oscs=(e,t,s,n=.5)=>{let a=0;t=Array.isArray(t)?t:[t];for(let r=0;r<t.length;r++)a+=self.osc(e,t[r],s,n);return a/t.length},self.adsr=(e,t=.2,s=.1,n=.4,a=.3,r=.5,u=null)=>(u=u||self._state.duration,e=e/u,e<0?0:e<=t?e/t:e<=t+s?1-(1-r)*(e-t)/s:e<=t+s+n?r:e<=t+s+n+a?r-(r-0)*(e-t-s-n)/a:0),self.lowpass=(e,t,s)=>{const n=++self._state.call,a=1/(2*Math.PI*s);if(self._state.n<0)return 0;if(!self._state[n]){const i=self._state.n;return self._state[n]={last_value:t*(i/(a+i)),last_x:0},self._state[n].last_value}const r=self._state[n],u=e-r.last_x;r.last_x=e;const o=u/(a+u);return r.last_value=r.last_value+o*(t-r.last_value)},self.highpass=(e,t,s)=>{const n=++self._state.call,a=1/(2*Math.PI*s);if(self._state.n<0)return 0;if(!self._state[n])return self._state[n]={last_value:t,last_input:t,last_x:0},self._state[n].last_value;const r=self._state[n],u=e-r.last_x;r.last_x=e;const o=a/(a+u);return r.last_value=o*(r.last_value+t-r.last_input),r.last_input=t,r.last_value},self.segment=(e,...t)=>{for(let s=0;s<t.length;s+=2)if(e<t[s])return t[s+1]},self.at=(e,t,s)=>t(s+e),self.__doc__=Object.fromEntries(Object.entries(S).map(([e,t])=>Object.entries(t).map(([s,n])=>[self[s],`${e}: ${n}`])).flat());const P={epsilon:1e-9,sampling:1500,subsampling:32,minBlockSize:10,precisionPass:8,precision:I/1024,extremumPass:32,straightness:1e-5,maxPoints:1e4,overflow:.1},U=(e,t,s,n,a)=>{var r,u;if(isNaN(t)||isNaN(s)||t<n[0][0]||t>n[0][1]||s<n[1][0]||s>n[1][1]){(r=e.out)!=null&&r.length||e.length>0&&e.push(t,s),e.out=[t,s];return}(u=e.out)!=null&&u.length&&(a==="linear-horizontal"?e.push(NaN,((e[e.length-1]||n[1][0])+e.out[1])/2):a==="linear"?e.push(((e[e.length-2]||n[0][0])+e.out[0])/2,NaN):e.push(NaN,NaN),e.push(...e.out),e.out.splice(0)),e.push(t,s)},D=(e,t,s,n,a,r,u,o)=>{if(s==="linear"){const i=o*n+(1-o)*r,p=t[0](i);e(i,p)}else if(s==="linear-horizontal"){const i=o*a+(1-o)*u,p=t[0](i);e(p,i)}},L=(e,t,s,n,a)=>{const[[r,u],[o,i]]=n,p=[],g=(N,_)=>U(p,N,_,n,s),b=(N,_,v,l,f)=>D(g,t,s,N,_,v,l,f),h=(i-o)/(u-r);let R=0;for(let N=0;N+R<e.length;N+=4){const _=e[N],v=e[N+1],l=e[N+2+R],f=e[N+3+R],z=e[N+4+R],x=e[N+5+R];if(s==="linear"&&(isNaN(v)||isNaN(f)||isNaN(x))||s==="linear-horizontal"&&(isNaN(_)||isNaN(l)||isNaN(z))){N+=R,R=0,g(_,v),g(l,f);continue}const m=Math.atan2(f-v,h*(l-_)),c=Math.atan2(x-f,h*(z-l))-m,d=Math.abs(c),B=((z-_)/(u-r))**2+((x-v)/(i-o))**2;if(d*B<P.straightness){N-=4,R+=2;continue}if(R&&(N+=R,R=0),a){g(_,v),g(l,f);continue}const A=d>P.precision;g(_,v),A&&b(_,v,l,f,1/2),g(l,f),A&&b(l,f,z,x,1/2)}return p},V=(e,t,s,n)=>{for(let a=2;a<e.length-2;a+=2){let r=e[a-2],u=e[a-1],o=e[a],i=e[a+1],p=e[a+2],g=e[a+3];const b=n[s==="linear-horizontal"?0:1];if(s==="linear-horizontal"&&([r,u]=[u,r],[o,i]=[i,o],[p,g]=[g,p]),isNaN(i)||isNaN(g)||isNaN(u))continue;const h=Math.sign(i-u),R=Math.sign(g-i);if(h!==R){let N=r,_=o,v=p,l=i;for(let f=0;f<P.extremumPass;f++){const z=(N+_)/2,x=t[0](z),m=(_+v)/2,w=t[0](m);if(Math.sign(x-l)===h?(v=_,_=z,l=x):Math.sign(w-l)===h?(N=_,_=m,l=w):(N=z,v=m),N===v||l>b[1]||l<b[0])break}e[a]=_,e[a+1]=l,s==="linear-horizontal"&&([e[a],e[a+1]]=[e[a+1],e[a]])}}},X=(e,t,s,n,a,r)=>{let u=[];for(let o=n;o<a;o+=r){const[i,p]=y(e,t,o);U(u,i,p,s,t)}u=L(u,e,t,s,!0),V(u,e,t,s);for(let o=0;o<P.precisionPass&&!(u.length>P.maxPoints);o++)u=L(u,e,t,s);return u},H=(e,t,s,n,a,r)=>{const u=a-n;n-=u*P.overflow/2,a+=u*P.overflow/2;const o=[];let i=[NaN,NaN],p=[NaN,NaN],g=y(e,t,n);const[b,h]=t==="linear-horizontal"?[1,0]:[0,1],R=s[t==="linear-horizontal"?0:1],N=s[t==="linear-horizontal"?1:0],_=(R[1]-R[0])/(N[1]-N[0]),v=(N[1]-N[0])*P.epsilon;let l=null,f={min:[],max:[]},z=!1;for(let x=n;x<=a;x+=r){if(p=i,i=g,g=y(e,t,x+r),isNaN(i[h])||isNaN(g[h])){o.push(i[0],i[1]);continue}if(!isNaN(p[h])&&!l&&x<a-r){const M=Math.atan2(i[h]-p[h],_*(i[b]-p[b])),E=Math.atan2(g[h]-i[h],_*(g[b]-i[b]))-M,$=Math.abs(E),k=((g[b]-p[b])/(N[1]-N[0]))**2+((g[h]-p[h])/(R[1]-R[0]))**2;if($*k<P.straightness){z=!0,i=p;continue}else z&&(z=!1,x-=r,g=i,i=p)}l||o.push(i[0],i[1]);let m=i[b],w=g[b],c=y(e,t,m+(w-m)/3),d=y(e,t,w-(w-m)/3);const B=Math.sign(c[h]-i[h]),A=Math.sign(d[h]-c[h]),j=Math.sign(g[h]-d[h]),F=j===-1?"max":"min";if(B!==A||A!==j)for(let M=0;M<P.extremumPass;M++){if(c[h]>R[1]&&d[h]<R[0]||c[h]<R[0]&&d[h]>R[1]){const q=y(e,t,(m+w)/2),E=Math.sign(q[h]-c[h]),$=Math.sign(d[h]-q[h]);if(E!==$){c[h]>d[h]?(f.max.push(c),f.min.push(d)):(f.max.push(d),f.min.push(c)),l?c[h]>d[h]?(l.max.push(c[0],c[1]),l.min.push(d[0],d[1])):(l.max.push(d[0],d[1]),l.min.push(c[0],c[1])):(o.push(c[0],c[1]),t==="linear-horizontal"?o.push(NaN,(c[1]+d[1])/2):o.push((c[0]+d[0])/2,NaN),o.push(d[0],d[1]));break}}if(j===-1?c[h]<d[h]?m=c[b]:w=d[b]:c[h]>d[h]?m=c[b]:w=d[b],Math.abs(w-m)<v||M===P.extremumPass-1){j===-1&&c[h]>d[h]||j===1&&c[h]<d[h]?(f[F].push(c),l?l[F].push(c[0],c[1]):o.push(c[0],c[1])):(f[F].push(d),l?l[F].push(d[0],d[1]):o.push(d[0],d[1]));break}c=y(e,t,m+(w-m)/3),d=y(e,t,w-(w-m)/3)}else if(f.max.length+f.min.length>0){let M=null,q=0,E=!1;for(let $=0;$<=P.subsampling;$++){let k=$===0?i:$===P.subsampling?g:y(e,t,((P.subsampling-$)*i[b]+$*g[b])/P.subsampling);if(M){const G=Math.sign(k[h]-M[h]);if(q&&G!==q){f[G===-1?"max":"min"].push(k),E=!0;break}q=G}M=k}E||(f.min.shift(),f.max.shift())}else f.min.shift(),f.max.shift();if(f.min.length>3&&f.min.shift(),f.max.length>3&&f.max.shift(),l){if(f.min.length<1&&f.max.length<1||x>a-r){if(l.min.length>2&&l.max.length>2){o.push(NaN,NaN);for(let M=0;M<l.min.length;M+=2)o.push(l.min[M],l.min[M+1]);t==="linear-horizontal"?(o.push(l.min[l.min.length-2],i[1]),o.push(l.max[l.max.length-2],i[1])):(o.push(i[0],l.min[l.min.length-1]),o.push(i[0],l.max[l.max.length-1]));for(let M=l.max.length-2;M>=0;M-=2)o.push(l.max[M],l.max[M+1]);o.push(NaN,NaN)}o.push(i[0],i[1]),l=null}}else if(f.min.length>=1&&f.max.length>=1){const M=f.min[f.min.length-1],q=f.max[f.max.length-1],E=Math.min(M[b],q[b]);l={min:t==="linear-horizontal"?[M[h],E]:[E,M[h]],max:t==="linear-horizontal"?[q[h],E]:[E,q[h]]}}}return o.push(g[0],g[1]),o},J=(e,t,s,n,a,r)=>{const u=[];for(let o=n;o<a;o+=r){const[i,p]=y(e,t,o);u.push(i,p)}return u},y=(e,t,s)=>{if(self._state.call=0,self._state.n=s,t==="parametric"){const n=e[0](s),a=e[1](s);return[n,a]}else if(t==="polar"){const n=e[0](s);return[n*Math.cos(s),n*Math.sin(s)]}else{if(t==="linear-horizontal")return[e[0](s),s];if(t==="linear"){const n=e[0](s);return[s,n]}}throw new Error(`Unknown plot type ${t}`)},Y=["line","dot","point"],T={};onmessage=({data:{index:e,funs:t,type:s,min:n,max:a,samples:r,region:u,affects:o,mode:i,rendering:p,recs:g,dimensions:b=2,sampleRate:h,duration:R,uuid:N}})=>{let _="",v=[],l;try{if(s==="unknown")throw new Error(`Invalid function type ${t.join(", ")}`);if(!Y.includes(i))throw new Error(`Invalid mode: ${i}, must be one of ${Y.join(", ")}`);typeof n=="string"&&(n=new Function("return "+n)()),typeof a=="string"&&(a=new Function("return "+a)()),typeof r=="string"&&(r=new Function("return "+r)());const f=(a-n)/r;if(isNaN(f)||f===0)throw new Error(`Invalid step ${f}`);p||(["linear","linear-horizontal"].includes(s)&&!Object.keys(S.sound).some(x=>t[0].match(new RegExp(`\\b${x}\\b`)))?p="auto":p="size");for(let x=0;x<o.length;x++){const[m,w]=o[x],c=new Function("","return "+w)();T[m]=self[m],self[m]=c}g&&Object.entries(g).forEach(([x,m])=>{!m||(self[`$rec${x}`]=w=>{const c=~~Math.round(w*m.sampleRate);return c>=0&&c<m.buffer.length?m.buffer[c]:0})}),self._state={sampleRate:h,duration:R,call:0,min:n,max:a,step:f};const z=t.map(x=>new Function(C[s],"return "+x));if(b===1){l=new Float32Array((a-n)/f);let x=0;for(let m=n;m<a;m+=f){self._state.call=0,self._state.n=m;const w=z[0](m);if(typeof w!="number"){let c;throw typeof w=="function"?c=new Error(self.__doc__[w]||"Function not supported"):typeof w>"u"?c=new Error(`${t[0]} is undefined`):c=new Error(`${typeof w} is not a number`),c}l[x++]=w}}else b===2&&(p==="size"?v=J(z,s,u,n,a,f):p==="adaptative"?v=X(z,s,u,n,a,f):p==="auto"&&(v=H(z,s,u,n,a,f)),l=new Float32Array(v));g&&Object.keys(g).forEach(x=>{delete self[`$rec${x}`]});for(let x=0;x<o.length;x++){const[m]=o[x];self[m]=T[m],delete T[m]}}catch(f){_=f}postMessage({index:e,values:l,type:s,mode:i,err:_,uuid:N},l==null?void 0:l.buffer)}})();

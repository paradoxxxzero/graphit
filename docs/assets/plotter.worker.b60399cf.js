(function(){"use strict";const G={linear:"x","linear-horizontal":"y",polar:"o",parametric:"t"};for(let e of Array.from(Object.getOwnPropertyNames(Math)))self[e.toLowerCase()]=self[e]=Math[e];const L=self.PI;self.tau=self.TAU=self.PI*2,self.eta=self.ETA=self.PI/2,self.ln=self.log,self.osc=(e,t,s="sine")=>t<0?0:s==="sine"?Math.sin(2*Math.PI*e*t):s==="square"?Math.sign(Math.sin(2*Math.PI*e*t)):s==="sawtooth"?2*(t*e-~~(t*e+.5)):s==="triangle"?2*Math.abs(2*(t*e+.25-~~(t*e+.75)))-1:0,self.adsr=(e,t=.2,s=.1,a=.4,l=.3,h=.5)=>e<0?0:e<=t?e/t:e<=t+s?1-(1-h)*(e-t)/s:e<=t+s+a?h:e<=t+s+a+l?h-(h-0)*(e-t-s-a)/l:0,self.__doc__={[self.adsr]:"adsr usage: (x, attack = 0.2, decay = 0.1, sustain = 0.4, release = 0.3, sustainLevel = 0.5)",[self.osc]:"osc usage: (freq, x, type = sine|square|sawtooth|triangle)",[self.abs]:"Returns the absolute value of x.",[self.acos]:"Returns the arccosine of x.",[self.acosh]:"Returns the hyperbolic arccosine of x.",[self.asin]:"Returns the arcsine of x.",[self.asinh]:"Returns the hyperbolic arcsine of a number.",[self.atan]:"Returns the arctangent of x.",[self.atanh]:"Returns the hyperbolic arctangent of x.",[self.atan2]:"Returns the arctangent of the quotient of its arguments.",[self.cbrt]:"Returns the cube root of x.",[self.ceil]:"Returns the smallest integer greater than or equal to x.",[self.clz32]:"Returns the number of leading zero bits of the 32-bit integer x.",[self.cos]:"Returns the cosine of x.",[self.cosh]:"Returns the hyperbolic cosine of x.",[self.exp]:"Returns ex, where x is the argument, and e is Euler's constant (2.718\u2026, the base of the natural logarithm).",[self.expm1]:"Returns subtracting 1 from exp(x).",[self.floor]:"Returns the largest integer less than or equal to x.",[self.fround]:"Returns the nearest single precision float representation of x.",[self.hypot]:"Returns the square root of the sum of squares of its arguments.",[self.imul]:"Returns the result of the 32-bit integer multiplication of x and y.",[self.log]:"Returns the natural logarithm (\u33D2e; also, \u33D1) of x.",[self.log1p]:"Returns the natural logarithm (\u33D2e; also \u33D1) of 1 + x for the number x.",[self.log10]:"Returns the base-10 logarithm of x.",[self.log2]:"Returns the base-2 logarithm of x.",[self.max]:"Returns the largest of zero or more numbers.",[self.min]:"Returns the smallest of zero or more numbers.",[self.pow]:"Returns base x to the exponent power y (that is, xy).",[self.random]:"Returns a pseudo-random number between 0 and 1.",[self.round]:"Returns the value of the number x rounded to the nearest integer.",[self.sign]:"Returns the sign of the x, indicating whether x is positive, negative, or zero.",[self.sin]:"Returns the sine of x.",[self.sinh]:"Returns the hyperbolic sine of x.",[self.sqrt]:"Returns the positive square root of x.",[self.tan]:"Returns the tangent of x.",[self.tanh]:"Returns the hyperbolic tangent of x.",[self.trunc]:"Returns the integer portion of x, removing any fractional digits."};const y={epsilon:1e-9,sampling:1500,subsampling:24,minBlockSize:10,precisionPass:8,precision:L/1024,extremumPass:16,straightness:1e-6,maxPoints:1e4},O=(e,t,s,a,l)=>{var h,i;if(isNaN(t)||isNaN(s)||t<a[0][0]||t>a[0][1]||s<a[1][0]||s>a[1][1]){(h=e.out)!=null&&h.length||e.length>0&&e.push(t,s),e.out=[t,s];return}(i=e.out)!=null&&i.length&&(l==="linear-horizontal"?e.push(NaN,((e[e.length-1]||a[1][0])+e.out[1])/2):l==="linear"?e.push(((e[e.length-2]||a[0][0])+e.out[0])/2,NaN):e.push(NaN,NaN),e.push(...e.out),e.out.splice(0)),e.push(t,s)},V=(e,t,s,a,l,h,i,g)=>{if(s==="linear"){const x=g*a+(1-g)*h,m=t[0](x);e(x,m)}else if(s==="linear-horizontal"){const x=g*l+(1-g)*i,m=t[0](x);e(m,x)}},p=(e,t,s,a,l)=>{const[[h,i],[g,x]]=a,m=[],w=(u,r)=>O(m,u,r,a,s),I=(u,r,o,n,f)=>V(w,t,s,u,r,o,n,f),M=(x-g)/(i-h);let b=0;for(let u=0;u+b<e.length;u+=4){const r=e[u],o=e[u+1],n=e[u+2+b],f=e[u+3+b],N=e[u+4+b],z=e[u+5+b];if(s==="linear"&&(isNaN(o)||isNaN(f)||isNaN(z))||s==="linear-horizontal"&&(isNaN(r)||isNaN(n)||isNaN(N))){u+=b,b=0,w(r,o),w(n,f);continue}const R=Math.atan2(f-o,M*(n-r)),B=Math.atan2(z-f,M*(N-n))-R,A=Math.abs(B),F=((N-r)/(i-h))**2+((z-o)/(x-g))**2;if(A*F<y.straightness){u-=4,b+=2;continue}if(b&&(u+=b,b=0),l){w(r,o),w(n,f);continue}const E=A>y.precision;w(r,o),E&&I(r,o,n,f,1/2),w(n,f),E&&I(n,f,N,z,1/2)}return m},X=(e,t,s,a)=>{for(let l=2;l<e.length-2;l+=2){let h=e[l-2],i=e[l-1],g=e[l],x=e[l+1],m=e[l+2],w=e[l+3];const I=a[s==="linear-horizontal"?0:1];if(s==="linear-horizontal"&&([h,i]=[i,h],[g,x]=[x,g],[m,w]=[w,m]),isNaN(x)||isNaN(w)||isNaN(i))continue;const M=Math.sign(x-i),b=Math.sign(w-x);if(M!==b){let u=h,r=g,o=m,n=x;for(let f=0;f<y.extremumPass;f++){const N=(u+r)/2,z=t[0](N),R=(r+o)/2,_=t[0](R);if(Math.sign(z-n)===M?(o=r,r=N,n=z):Math.sign(_-n)===M?(u=r,r=R,n=_):(u=N,o=R),u===o||n>I[1]||n<I[0])break}e[l]=r,e[l+1]=n,s==="linear-horizontal"&&([e[l],e[l+1]]=[e[l+1],e[l]])}}},D=(e,t,s,a,l,h)=>{let i=[];for(let g=a;g<l;g+=h){const[x,m]=j(e,g,t);O(i,x,m,s,t)}i=p(i,e,t,s,!0),X(i,e,t,s);for(let g=0;g<y.precisionPass&&!(i.length>y.maxPoints);g++)i=p(i,e,t,s);return i},H=(e,t,s,a,l,h)=>{const i=[],[[g,x],[m,w]]=s,I=(w-m)/(x-g);let M=[NaN,NaN],b=[NaN,NaN],u=j(e,a,t),r=null;const[o,n]=t==="linear-horizontal"?[1,0]:[0,1],f=s[t==="linear-horizontal"?0:1],N=s[t==="linear-horizontal"?1:0],z=(N[1]-N[0])*y.epsilon;let R=!1,_=[],B,A=a;for(let F=a;F<=l;F+=h){if(B=A,A=j(e,F,t),!isNaN(A[n])&&F<l-h){const c=Math.atan2(M[n]-b[n],I*(M[o]-b[o])),d=Math.atan2(A[n]-M[n],I*(A[o]-M[o]))-c,v=Math.abs(d),$=((A[o]-b[o])/(x-g))**2+((A[n]-b[n])/(w-m))**2;if(v*$<y.straightness)continue}let E=[],k=null,Y=0,q=[void 0,void 0];for(let c=F;c<F+h;c+=h/y.subsampling){if(M=u,u=j(e,c,t),!(isNaN(b[n])||isNaN(M[n])||isNaN(u[n]))){const P=Math.sign(u[n]-M[n]);if(P!==0&&Y!==0&&P!==Y&&E.length<2){let d=b[o],v=u[o];for(let $=0;$<y.extremumPass;$++){const S=j(e,d+(v-d)/3,t),T=j(e,v-(v-d)/3,t);if(P===-1?S[n]<T[n]?d=S[o]:v=T[o]:P===1&&(S[n]>T[n]?d=S[o]:v=T[o]),Math.abs(v-d)<z||P===-1&&S[n]>f[1]&&T[n]>f[1]||P===1&&S[n]<f[0]&&T[n]<f[0]||S[n]>f[1]&&T[n]<f[0]||S[n]<f[0]&&T[n]>f[1])break}k=j(e,(d+v)/2,t),E.push(k),R?P===1?q[0]=q[0]===void 0?k[n]:Math.min(q[0],k[n]):P===-1&&(q[1]=q[1]===void 0?k[n]:Math.max(q[1],k[n])):i.push(k[o],k[n])}if(_.length+E.length>1&&!R){R=!0;let d=1/0,v=-1/0;for(let $=i.length-2;$>0&&!(!isNaN(i[$+n])&&(d=Math.min(d,i[$+n]),v=Math.max(v,i[$+n]),i[$+o]<B[o]));$-=2);r=[],d!==1/0&&v!==-1/0&&(r=[[B[o],[d,v]]]);continue}Y=P}b=M}if(R){if(E.length>0&&r.push([M[o],q]),E.length<1||F>l-h){if(R=!1,r.length>y.minBlockSize){i.push(NaN,NaN);for(let c=0;c<r.length;c++){const[P,d]=r[c];d[0]!==void 0&&i.push(P,d[0])}for(let c=r.length-1;c>=0;c--){const[P,d]=r[c];d[1]!==void 0&&i.push(P,d[1])}i.push(NaN,NaN);for(let c=0;c<_.length;c++)i.push(_[c][o],_[c][n]);for(let c=0;c<E.length;c++)i.push(E[c][o],E[c][n])}else for(let c=0;c<r.length;c++){const[P,d]=r[c];d[c%2]!==void 0&&i.push(P,d[c%2]),d[(c+1)%2]!==void 0&&i.push(P,d[(c+1)%2])}r=null}}else i.push(M[o],M[n]);_=E}return i.push(u[o],u[n]),i},J=(e,t,s,a,l,h)=>{const i=[];for(let g=a;g<l;g+=h){const[x,m]=j(e,g,t);O(i,x,m,s,t)}return i},j=(e,t,s)=>{if(s==="parametric")return[e[0](t),e[1](t)];if(s==="polar"){const a=e[0](t);return[a*Math.cos(t),a*Math.sin(t)]}else{if(s==="linear-horizontal")return[e[0](t),t];if(s==="linear")return[t,e[0](t)]}throw new Error(`Unknown plot type ${s}`)},C=["line","dot","point"],U={};onmessage=({data:{index:e,funs:t,type:s,min:a,max:l,samples:h,region:i,affects:g,mode:x,rendering:m,recs:w,dimensions:I=2,uuid:M}})=>{let b="",u=[],r;try{if(s==="unknown")throw new Error(`Invalid function type ${t.join(", ")}`);if(!C.includes(x))throw new Error(`Invalid mode: ${x}, must be one of ${C.join(", ")}`);typeof a=="string"&&(a=new Function("return "+a)()),typeof l=="string"&&(l=new Function("return "+l)()),typeof h=="string"&&(h=new Function("return "+h)());const o=(l-a)/h;if(isNaN(o)||o===0)throw new Error(`Invalid step ${o}`);m||(["linear","linear-horizontal"].includes(s)?m="auto":m="size");for(let f=0;f<g.length;f++){const[N,z]=g[f],R=new Function("","return "+z)();U[N]=self[N],self[N]=R}w&&Object.entries(w).forEach(([f,N])=>{!N||(self[`$rec${f}`]=z=>{const R=~~Math.round(z*N.sampleRate);return R>=0&&R<N.buffer.length?N.buffer[R]:0})});const n=t.map(f=>new Function(G[s],"return "+f));if(I===1){r=new Float32Array((l-a)/o);let f=0;for(let N=a;N<l;N+=o){const z=n[0](N);if(typeof z!="number"){let R;throw typeof z=="function"?R=new Error(self.__doc__[z]||"Function not supported"):typeof z>"u"?R=new Error(`${t[0]} is undefined`):R=new Error(`${typeof z} is not a number`),R}r[f++]=z}}else I===2&&(m==="size"?u=J(n,s,i,a,l,o):m==="adaptative"?u=D(n,s,i,a,l,o):m==="auto"&&(u=H(n,s,i,a,l,o)),r=new Float32Array(u));w&&Object.keys(w).forEach(f=>{delete self[`$rec${f}`]});for(let f=0;f<g.length;f++){const[N]=g[f];self[N]=U[N],delete U[N]}}catch(o){b=o}postMessage({index:e,values:r,type:s,mode:x,err:b,uuid:M},r==null?void 0:r.buffer)}})();

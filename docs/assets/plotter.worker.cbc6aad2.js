(function(){"use strict";const F={linear:"x","linear-horizontal":"y",polar:"o",parametric:"t"};for(let e of Array.from(Object.getOwnPropertyNames(Math)))self[e.toLowerCase()]=self[e]=Math[e];const _=self.PI;self.tau=self.TAU=self.PI*2,self.eta=self.ETA=self.PI/2,self.ln=self.log,self.osc=(e,s,t="sine")=>s<0?0:t==="sine"?Math.sin(2*Math.PI*e*s):t==="square"?Math.sign(Math.sin(2*Math.PI*e*s)):t==="sawtooth"?2*(s*e-~~(s*e+.5)):t==="triangle"?2*Math.abs(2*(s*e+.25-~~(s*e+.75)))-1:0,self.adsr=(e,s=.2,t=.1,a=.4,r=.3,u=.5)=>e<0?0:e<=s?e/s:e<=s+t?1-(1-u)*(e-s)/t:e<=s+t+a?u:e<=s+t+a+r?u-(u-0)*(e-s-t-a)/r:0,self.__doc__={[self.adsr]:"adsr usage: (x, attack = 0.2, decay = 0.1, sustain = 0.4, release = 0.3, sustainLevel = 0.5)",[self.osc]:"osc usage: (freq, x, type = sine|square|sawtooth|triangle)",[self.abs]:"Returns the absolute value of x.",[self.acos]:"Returns the arccosine of x.",[self.acosh]:"Returns the hyperbolic arccosine of x.",[self.asin]:"Returns the arcsine of x.",[self.asinh]:"Returns the hyperbolic arcsine of a number.",[self.atan]:"Returns the arctangent of x.",[self.atanh]:"Returns the hyperbolic arctangent of x.",[self.atan2]:"Returns the arctangent of the quotient of its arguments.",[self.cbrt]:"Returns the cube root of x.",[self.ceil]:"Returns the smallest integer greater than or equal to x.",[self.clz32]:"Returns the number of leading zero bits of the 32-bit integer x.",[self.cos]:"Returns the cosine of x.",[self.cosh]:"Returns the hyperbolic cosine of x.",[self.exp]:"Returns ex, where x is the argument, and e is Euler's constant (2.718\u2026, the base of the natural logarithm).",[self.expm1]:"Returns subtracting 1 from exp(x).",[self.floor]:"Returns the largest integer less than or equal to x.",[self.fround]:"Returns the nearest single precision float representation of x.",[self.hypot]:"Returns the square root of the sum of squares of its arguments.",[self.imul]:"Returns the result of the 32-bit integer multiplication of x and y.",[self.log]:"Returns the natural logarithm (\u33D2e; also, \u33D1) of x.",[self.log1p]:"Returns the natural logarithm (\u33D2e; also \u33D1) of 1 + x for the number x.",[self.log10]:"Returns the base-10 logarithm of x.",[self.log2]:"Returns the base-2 logarithm of x.",[self.max]:"Returns the largest of zero or more numbers.",[self.min]:"Returns the smallest of zero or more numbers.",[self.pow]:"Returns base x to the exponent power y (that is, xy).",[self.random]:"Returns a pseudo-random number between 0 and 1.",[self.round]:"Returns the value of the number x rounded to the nearest integer.",[self.sign]:"Returns the sign of the x, indicating whether x is positive, negative, or zero.",[self.sin]:"Returns the sine of x.",[self.sinh]:"Returns the hyperbolic sine of x.",[self.sqrt]:"Returns the positive square root of x.",[self.tan]:"Returns the tangent of x.",[self.tanh]:"Returns the hyperbolic tangent of x.",[self.trunc]:"Returns the integer portion of x, removing any fractional digits."};const P={sampling:1500,precisionPass:8,precision:_/1024,extremumPass:64,straightness:1e-6,maxPoints:1e4},z=(e,s,t,a,r)=>{var u,d;if(isNaN(s)||isNaN(t)||s<a[0][0]||s>a[0][1]||t<a[1][0]||t>a[1][1]){(u=e.out)!=null&&u.length||e.length>0&&e.push(s,t),e.out=[s,t];return}(d=e.out)!=null&&d.length&&(r==="linear-horizontal"?e.push(NaN,((e[e.length-1]||a[1][0])+e.out[1])/2):r==="linear"&&e.push(((e[e.length-2]||a[0][0])+e.out[0])/2,NaN),e.push(...e.out),e.out.splice(0)),e.push(s,t)},j=(e,s,t,a,r,u,d,m)=>{if(t==="linear"){const g=m*a+(1-m)*u,R=s[0](g);e(g,R)}else if(t==="linear-horizontal"){const g=m*r+(1-m)*d,R=s[0](g);e(R,g)}},E=(e,s,t,a,r)=>{const[[u,d],[m,g]]=a,R=[],w=(l,h)=>z(R,l,h,a,t),M=(l,h,c,i,n)=>j(w,s,t,l,h,c,i,n),N=(g-m)/(d-u);let b=0;for(let l=0;l+b<e.length;l+=4){const h=e[l],c=e[l+1],i=e[l+2+b],n=e[l+3+b],o=e[l+4+b],f=e[l+5+b];if(t==="linear"&&(isNaN(c)||isNaN(n)||isNaN(f))||t==="linear-horizontal"&&(isNaN(h)||isNaN(i)||isNaN(o))){l+=b,b=0,w(h,c),w(i,n);continue}const x=Math.atan2(n-c,N*(i-h)),T=Math.atan2(f-n,N*(o-i))-x,$=Math.abs(T),B=((o-h)/(d-u))**2+((f-c)/(g-m))**2;if($*B<P.straightness){l-=4,b+=2;continue}if(b&&(l+=b,b=0),r){w(h,c),w(i,n);continue}const A=$>P.precision;w(h,c),A&&M(h,c,i,n,1/2),w(i,n),A&&M(i,n,o,f,1/2)}return R},q=(e,s,t,a)=>{for(let r=2;r<e.length-2;r+=2){let u=e[r-2],d=e[r-1],m=e[r],g=e[r+1],R=e[r+2],w=e[r+3];const M=a[t==="linear-horizontal"?0:1];if(t==="linear-horizontal"&&([u,d]=[d,u],[m,g]=[g,m],[R,w]=[w,R]),isNaN(g)||isNaN(w)||isNaN(d))continue;const N=Math.sign(g-d),b=Math.sign(w-g);if(N!==b){let l=u,h=m,c=R,i=g;for(let n=0;n<P.extremumPass;n++){const o=(l+h)/2,f=s[0](o),x=(h+c)/2,v=s[0](x);if(Math.sign(f-i)===N?(c=h,h=o,i=f):Math.sign(v-i)===N?(l=h,h=x,i=v):(l=o,c=x),i>M[1]||i<M[0])break}e[r]=h,e[r+1]=i,t==="linear-horizontal"&&([e[r],e[r+1]]=[e[r+1],e[r]])}}},O=(e,s,t,a)=>{e=E(e,s,t,a,!0),q(e,s,t,a);for(let r=0;r<P.precisionPass&&!(e.length>P.maxPoints);r++)e=E(e,s,t,a);return e},I=["line","dot","point"],y={};onmessage=({data:{index:e,funs:s,type:t,min:a,max:r,samples:u,region:d,affects:m,mode:g,recs:R,dimensions:w=2,uuid:M}})=>{let N="",b=[],l,h=!1;try{if(t==="unknown")throw new Error(`Invalid function type ${s.join(", ")}`);if(!I.includes(g))throw new Error(`Invalid mode: ${g}, must be one of ${I.join(", ")}`);typeof a=="string"&&(a=new Function("return "+a)()),typeof r=="string"&&(r=new Function("return "+r)()),typeof u=="string"&&(u==="auto"?(h=!0,u=P.sampling):u=new Function("return "+u)());const c=(r-a)/u;if(isNaN(c)||c<1e-9)throw new Error(`Invalid step ${c}`);for(let n=0;n<m.length;n++){const[o,f]=m[n],x=new Function("","return "+f)();y[o]=self[o],self[o]=x}R&&Object.entries(R).forEach(([n,o])=>{!o||(self[`$rec${n}`]=f=>{const x=~~Math.round(f*o.sampleRate);return x>=0&&x<o.buffer.length?o.buffer[x]:0})});const i=s.map(n=>new Function(F[t],"return "+n));if(w===1){l=new Float32Array((r-a)/c);let n=0;for(let o=a;o<r;o+=c){const f=i[0](o);if(typeof f!="number"){let x;throw typeof f=="function"?x=new Error(self.__doc__[f]||"Function not supported"):typeof f>"u"?x=new Error(`${s[0]} is undefined`):x=new Error(`${typeof f} is not a number`),x}l[n++]=f}}else if(w===2){for(let n=a;n<r;n+=c){let o,f;if(t==="parametric")o=i[0](n),f=i[1](n);else if(t==="polar"){const x=i[0](n);o=x*Math.cos(n),f=x*Math.sin(n)}else t==="linear-horizontal"?(o=i[0](n),f=n):(o=n,f=i[0](n));z(b,o,f,d,t)}h&&(b=new Float32Array(O(b,i,t,d))),l=new Float32Array(b)}R&&Object.keys(R).forEach(n=>{delete self[`$rec${n}`]});for(let n=0;n<m.length;n++){const[o]=m[n];self[o]=y[o],delete y[o]}}catch(c){N=c}postMessage({index:e,values:l,type:t,mode:g,err:N,uuid:M},l==null?void 0:l.buffer)}})();

(function(){"use strict";const $={linear:"x","linear-horizontal":"y",polar:"o",parametric:"t"};for(let e of Array.from(Object.getOwnPropertyNames(Math)))self[e.toLowerCase()]=self[e]=Math[e];const F=self.PI;self.tau=self.TAU=self.PI*2,self.eta=self.ETA=self.PI/2,self.ln=self.log,self.osc=(e,n,t="sine")=>n<0?0:t==="sine"?Math.sin(2*Math.PI*e*n):t==="square"?Math.sign(Math.sin(2*Math.PI*e*n)):t==="sawtooth"?2*(n*e-~~(n*e+.5)):t==="triangle"?2*Math.abs(2*(n*e+.25-~~(n*e+.75)))-1:0,self.adsr=(e,n=.2,t=.1,o=.4,s=.3,f=.5)=>e<0?0:e<=n?e/n:e<=n+t?1-(1-f)*(e-n)/t:e<=n+t+o?f:e<=n+t+o+s?f-(f-0)*(e-n-t-o)/s:0,self.__doc__={[self.adsr]:"adsr usage: (x, attack = 0.2, decay = 0.1, sustain = 0.4, release = 0.3, sustainLevel = 0.5)",[self.osc]:"osc usage: (freq, x, type = sine|square|sawtooth|triangle)",[self.abs]:"Returns the absolute value of x.",[self.acos]:"Returns the arccosine of x.",[self.acosh]:"Returns the hyperbolic arccosine of x.",[self.asin]:"Returns the arcsine of x.",[self.asinh]:"Returns the hyperbolic arcsine of a number.",[self.atan]:"Returns the arctangent of x.",[self.atanh]:"Returns the hyperbolic arctangent of x.",[self.atan2]:"Returns the arctangent of the quotient of its arguments.",[self.cbrt]:"Returns the cube root of x.",[self.ceil]:"Returns the smallest integer greater than or equal to x.",[self.clz32]:"Returns the number of leading zero bits of the 32-bit integer x.",[self.cos]:"Returns the cosine of x.",[self.cosh]:"Returns the hyperbolic cosine of x.",[self.exp]:"Returns ex, where x is the argument, and e is Euler's constant (2.718\u2026, the base of the natural logarithm).",[self.expm1]:"Returns subtracting 1 from exp(x).",[self.floor]:"Returns the largest integer less than or equal to x.",[self.fround]:"Returns the nearest single precision float representation of x.",[self.hypot]:"Returns the square root of the sum of squares of its arguments.",[self.imul]:"Returns the result of the 32-bit integer multiplication of x and y.",[self.log]:"Returns the natural logarithm (\u33D2e; also, \u33D1) of x.",[self.log1p]:"Returns the natural logarithm (\u33D2e; also \u33D1) of 1 + x for the number x.",[self.log10]:"Returns the base-10 logarithm of x.",[self.log2]:"Returns the base-2 logarithm of x.",[self.max]:"Returns the largest of zero or more numbers.",[self.min]:"Returns the smallest of zero or more numbers.",[self.pow]:"Returns base x to the exponent power y (that is, xy).",[self.random]:"Returns a pseudo-random number between 0 and 1.",[self.round]:"Returns the value of the number x rounded to the nearest integer.",[self.sign]:"Returns the sign of the x, indicating whether x is positive, negative, or zero.",[self.sin]:"Returns the sine of x.",[self.sinh]:"Returns the hyperbolic sine of x.",[self.sqrt]:"Returns the positive square root of x.",[self.tan]:"Returns the tangent of x.",[self.tanh]:"Returns the hyperbolic tangent of x.",[self.trunc]:"Returns the integer portion of x, removing any fractional digits."};const P={sampling:1500,precisionPass:16,precision:F/1024,extremumPass:64,straightness:1e-6,maxPoints:1e4},z=(e,n,t,o,s)=>{var f,w;if(isNaN(n)||isNaN(t)||n<o[0][0]||n>o[0][1]||t<o[1][0]||t>o[1][1]){(f=e.out)!=null&&f.length||e.length>0&&e.push(n,t),e.out=[n,t];return}(w=e.out)!=null&&w.length&&(s==="linear-horizontal"?e.push(NaN,((e[e.length-1]||o[1][0])+e.out[1])/2):s==="linear"&&e.push(((e[e.length-2]||o[0][0])+e.out[0])/2,NaN),e.push(...e.out),e.out.splice(0)),e.push(n,t)},_=(e,n,t,o,s,f,w,R)=>{if(t==="linear"){const g=R*o+(1-R)*f,l=n[0](g);e(g,l)}else if(t==="linear-horizontal"){const g=R*s+(1-R)*w,l=n[0](g);e(l,g)}},j=(e,n,t,o)=>{const[[s,f],[w,R]]=o,g=[],l=(u,N)=>z(g,u,N,o,t),x=(u,N,c,h,i)=>_(l,n,t,u,N,c,h,i),M=(R-w)/(f-s);for(let u=0;u<e.length;u+=4){const N=e[u],c=e[u+1],h=e[u+2],i=e[u+3],b=e[u+4],r=e[u+5];if(t==="linear"&&(isNaN(c)||isNaN(i)||isNaN(r))||t==="linear-horizontal"&&(isNaN(N)||isNaN(h)||isNaN(b))){l(N,c),l(h,i);continue}const a=Math.atan2(i-c,M*(h-N)),d=Math.atan2(r-i,M*(b-h))-a,I=Math.abs(d)>P.precision;l(N,c),I&&x(N,c,h,i,1/2),l(h,i),I&&x(h,i,b,r,1/2)}return g},q=(e,n,t,o)=>{for(let s=2;s<e.length-2;s+=2){let f=e[s-2],w=e[s-1],R=e[s],g=e[s+1],l=e[s+2],x=e[s+3];const M=o[t==="linear-horizontal"?0:1];if(t==="linear-horizontal"&&([f,w]=[w,f],[R,g]=[g,R],[l,x]=[x,l]),isNaN(g)||isNaN(x)||isNaN(w))continue;const u=Math.sign(g-w),N=Math.sign(x-g);if(u!==N){let c=f,h=R,i=l,b=g;for(let r=0;r<P.extremumPass;r++){const a=(c+h)/2,m=n[0](a),d=(h+i)/2,v=n[0](d);if(Math.sign(m-b)===u?(i=h,h=a,b=m):Math.sign(v-b)===u?(c=h,h=d,b=v):(c=a,i=d),b>M[1]||b<M[0])break}e[s]=h,e[s+1]=b,t==="linear-horizontal"&&([e[s],e[s+1]]=[e[s+1],e[s]])}}},E=(e,n,t)=>{const[[o,s],[f,w]]=t,R=[],g=(w-f)/(s-o);let l=0;for(let x=0;x+l<e.length;x+=2){const M=e[x],u=e[x+1],N=e[x+2+l],c=e[x+3+l],h=e[x+4+l],i=e[x+5+l];if(n==="linear"&&(isNaN(u)||isNaN(c)||isNaN(i))||n==="linear-horizontal"&&(isNaN(M)||isNaN(N)||isNaN(h))){x+=l,l=0,R.push(M,u);continue}const b=Math.atan2(c-u,g*(N-M)),a=Math.atan2(i-c,g*(h-N))-b,m=((h-M)/(s-o))**2+((i-u)/(w-f))**2;Math.abs(a)*m<P.straightness?(x-=2,l+=2):(R.push(M,u),x+=l,l=0)}return R},O=(e,n,t,o)=>{e=E(e,t,o),q(e,n,t,o);for(let s=0;s<P.precisionPass&&!(e.length>P.maxPoints);s++)e=j(e,n,t,o);return e=E(e,t,o),e},A=["line","dot","point"],y={};onmessage=({data:{index:e,funs:n,type:t,min:o,max:s,samples:f,region:w,affects:R,mode:g,recs:l,dimensions:x=2,uuid:M}})=>{let u="",N=[],c,h=!1;try{if(t==="unknown")throw new Error(`Invalid function type ${n.join(", ")}`);if(!A.includes(g))throw new Error(`Invalid mode: ${g}, must be one of ${A.join(", ")}`);typeof o=="string"&&(o=new Function("return "+o)()),typeof s=="string"&&(s=new Function("return "+s)()),typeof f=="string"&&(f==="auto"?(h=!0,f=P.sampling):f=new Function("return "+f)());const i=(s-o)/f;if(isNaN(i)||i<1e-9)throw new Error(`Invalid step ${i}`);for(let r=0;r<R.length;r++){const[a,m]=R[r],d=new Function("","return "+m)();y[a]=self[a],self[a]=d}l&&Object.entries(l).forEach(([r,a])=>{!a||(self[`$rec${r}`]=m=>{const d=~~Math.round(m*a.sampleRate);return d>=0&&d<a.buffer.length?a.buffer[d]:0})});const b=n.map(r=>new Function($[t],"return "+r));if(x===1){c=new Float32Array((s-o)/i);let r=0;for(let a=o;a<s;a+=i){const m=b[0](a);if(typeof m!="number"){let d;throw typeof m=="function"?d=new Error(self.__doc__[m]||"Function not supported"):typeof m>"u"?d=new Error(`${n[0]} is undefined`):d=new Error(`${typeof m} is not a number`),d}c[r++]=m}}else if(x===2){for(let r=o;r<s;r+=i){let a,m;if(t==="parametric")a=b[0](r),m=b[1](r);else if(t==="polar"){const d=b[0](r);a=d*Math.cos(r),m=d*Math.sin(r)}else t==="linear-horizontal"?(a=b[0](r),m=r):(a=r,m=b[0](r));z(N,a,m,w,t)}h&&(N=new Float32Array(O(N,b,t,w))),c=new Float32Array(N)}l&&Object.keys(l).forEach(r=>{delete self[`$rec${r}`]});for(let r=0;r<R.length;r++){const[a]=R[r];self[a]=y[a],delete y[a]}}catch(i){u=i}postMessage({index:e,values:c,type:t,mode:g,err:u,uuid:M},c==null?void 0:c.buffer)}})();

(function(){"use strict";const Y={linear:"x","linear-horizontal":"y",polar:"o",parametric:"t"};for(let e of Array.from(Object.getOwnPropertyNames(Math)))self[e.toLowerCase()]=self[e]=Math[e];const C=self.PI;self.tau=self.TAU=self.PI*2,self.eta=self.ETA=self.PI/2,self.ln=self.log,self.osc=(e,t,i="sine")=>t<0?0:i==="sine"?Math.sin(2*Math.PI*e*t):i==="square"?Math.sign(Math.sin(2*Math.PI*e*t)):i==="sawtooth"?2*(t*e-~~(t*e+.5)):i==="triangle"?2*Math.abs(2*(t*e+.25-~~(t*e+.75)))-1:0,self.adsr=(e,t=.2,i=.1,f=.4,r=.3,g=.5)=>e<0?0:e<=t?e/t:e<=t+i?1-(1-g)*(e-t)/i:e<=t+i+f?g:e<=t+i+f+r?g-(g-0)*(e-t-i-f)/r:0,self.__doc__={[self.adsr]:"adsr usage: (x, attack = 0.2, decay = 0.1, sustain = 0.4, release = 0.3, sustainLevel = 0.5)",[self.osc]:"osc usage: (freq, x, type = sine|square|sawtooth|triangle)",[self.abs]:"Returns the absolute value of x.",[self.acos]:"Returns the arccosine of x.",[self.acosh]:"Returns the hyperbolic arccosine of x.",[self.asin]:"Returns the arcsine of x.",[self.asinh]:"Returns the hyperbolic arcsine of a number.",[self.atan]:"Returns the arctangent of x.",[self.atanh]:"Returns the hyperbolic arctangent of x.",[self.atan2]:"Returns the arctangent of the quotient of its arguments.",[self.cbrt]:"Returns the cube root of x.",[self.ceil]:"Returns the smallest integer greater than or equal to x.",[self.clz32]:"Returns the number of leading zero bits of the 32-bit integer x.",[self.cos]:"Returns the cosine of x.",[self.cosh]:"Returns the hyperbolic cosine of x.",[self.exp]:"Returns ex, where x is the argument, and e is Euler's constant (2.718\u2026, the base of the natural logarithm).",[self.expm1]:"Returns subtracting 1 from exp(x).",[self.floor]:"Returns the largest integer less than or equal to x.",[self.fround]:"Returns the nearest single precision float representation of x.",[self.hypot]:"Returns the square root of the sum of squares of its arguments.",[self.imul]:"Returns the result of the 32-bit integer multiplication of x and y.",[self.log]:"Returns the natural logarithm (\u33D2e; also, \u33D1) of x.",[self.log1p]:"Returns the natural logarithm (\u33D2e; also \u33D1) of 1 + x for the number x.",[self.log10]:"Returns the base-10 logarithm of x.",[self.log2]:"Returns the base-2 logarithm of x.",[self.max]:"Returns the largest of zero or more numbers.",[self.min]:"Returns the smallest of zero or more numbers.",[self.pow]:"Returns base x to the exponent power y (that is, xy).",[self.random]:"Returns a pseudo-random number between 0 and 1.",[self.round]:"Returns the value of the number x rounded to the nearest integer.",[self.sign]:"Returns the sign of the x, indicating whether x is positive, negative, or zero.",[self.sin]:"Returns the sine of x.",[self.sinh]:"Returns the hyperbolic sine of x.",[self.sqrt]:"Returns the positive square root of x.",[self.tan]:"Returns the tangent of x.",[self.tanh]:"Returns the hyperbolic tangent of x.",[self.trunc]:"Returns the integer portion of x, removing any fractional digits."};const E={epsilon:1e-9,sampling:1500,subsampling:32,minBlockSize:10,precisionPass:8,precision:C/1024,extremumPass:32,straightness:1e-5,maxPoints:1e4,overflow:.1},G=(e,t,i,f,r)=>{var g,m;if(isNaN(t)||isNaN(i)||t<f[0][0]||t>f[0][1]||i<f[1][0]||i>f[1][1]){(g=e.out)!=null&&g.length||e.length>0&&e.push(t,i),e.out=[t,i];return}(m=e.out)!=null&&m.length&&(r==="linear-horizontal"?e.push(NaN,((e[e.length-1]||f[1][0])+e.out[1])/2):r==="linear"?e.push(((e[e.length-2]||f[0][0])+e.out[0])/2,NaN):e.push(NaN,NaN),e.push(...e.out),e.out.splice(0)),e.push(t,i)},L=(e,t,i,f,r,g,m,a)=>{if(i==="linear"){const l=a*f+(1-a)*g,N=t[0](l);e(l,N)}else if(i==="linear-horizontal"){const l=a*r+(1-a)*m,N=t[0](l);e(N,l)}},S=(e,t,i,f,r)=>{const[[g,m],[a,l]]=f,N=[],h=(u,b)=>G(N,u,b,f,i),M=(u,b,w,s,n)=>L(h,t,i,u,b,w,s,n),o=(l-a)/(m-g);let z=0;for(let u=0;u+z<e.length;u+=4){const b=e[u],w=e[u+1],s=e[u+2+z],n=e[u+3+z],d=e[u+4+z],P=e[u+5+z];if(i==="linear"&&(isNaN(w)||isNaN(n)||isNaN(P))||i==="linear-horizontal"&&(isNaN(b)||isNaN(s)||isNaN(d))){u+=z,z=0,h(b,w),h(s,n);continue}const R=Math.atan2(n-w,o*(s-b)),x=Math.atan2(P-n,o*(d-s))-R,c=Math.abs(x),O=((d-b)/(m-g))**2+((P-w)/(l-a))**2;if(c*O<E.straightness){u-=4,z+=2;continue}if(z&&(u+=z,z=0),r){h(b,w),h(s,n);continue}const F=c>E.precision;h(b,w),F&&M(b,w,s,n,1/2),h(s,n),F&&M(s,n,d,P,1/2)}return N},V=(e,t,i,f)=>{for(let r=2;r<e.length-2;r+=2){let g=e[r-2],m=e[r-1],a=e[r],l=e[r+1],N=e[r+2],h=e[r+3];const M=f[i==="linear-horizontal"?0:1];if(i==="linear-horizontal"&&([g,m]=[m,g],[a,l]=[l,a],[N,h]=[h,N]),isNaN(l)||isNaN(h)||isNaN(m))continue;const o=Math.sign(l-m),z=Math.sign(h-l);if(o!==z){let u=g,b=a,w=N,s=l;for(let n=0;n<E.extremumPass;n++){const d=(u+b)/2,P=t[0](d),R=(b+w)/2,p=t[0](R);if(Math.sign(P-s)===o?(w=b,b=d,s=P):Math.sign(p-s)===o?(u=b,b=R,s=p):(u=d,w=R),u===w||s>M[1]||s<M[0])break}e[r]=b,e[r+1]=s,i==="linear-horizontal"&&([e[r],e[r+1]]=[e[r+1],e[r]])}}},X=(e,t,i,f,r,g)=>{let m=[];for(let a=f;a<r;a+=g){const[l,N]=A(e,a,t);G(m,l,N,i,t)}m=S(m,e,t,i,!0),V(m,e,t,i);for(let a=0;a<E.precisionPass&&!(m.length>E.maxPoints);a++)m=S(m,e,t,i);return m},D=(e,t,i,f,r,g)=>{const m=r-f;f-=m*E.overflow/2,r+=m*E.overflow/2;const a=[];let l=[NaN,NaN],N=[NaN,NaN],h=A(e,f,t);const[M,o]=t==="linear-horizontal"?[1,0]:[0,1],z=i[t==="linear-horizontal"?0:1],u=i[t==="linear-horizontal"?1:0],b=(z[1]-z[0])/(u[1]-u[0]),w=(u[1]-u[0])*E.epsilon;let s=null,n={min:[],max:[]},d=!1;for(let P=f;P<=r;P+=g){if(N=l,l=h,h=A(e,P+g,t),isNaN(l[o])||isNaN(h[o])){a.push(l[0],l[1]);continue}if(!isNaN(N[o])&&!s&&P<r-g){const v=Math.atan2(l[o]-N[o],b*(l[M]-N[M])),I=Math.atan2(h[o]-l[o],b*(h[M]-l[M]))-v,_=Math.abs(I),T=((h[M]-N[M])/(u[1]-u[0]))**2+((h[o]-N[o])/(z[1]-z[0]))**2;if(_*T<E.straightness){d=!0,l=N;continue}else d&&(d=!1,P-=g,h=l,l=N)}s||a.push(l[0],l[1]);let R=l[M],p=h[M],x=A(e,R+(p-R)/3,t),c=A(e,p-(p-R)/3,t);const O=Math.sign(x[o]-l[o]),F=Math.sign(c[o]-x[o]),j=Math.sign(h[o]-c[o]),k=j===-1?"max":"min";if(O!==F||F!==j)for(let v=0;v<E.extremumPass;v++){if(x[o]>z[1]&&c[o]<z[0]||x[o]<z[0]&&c[o]>z[1]){const $=A(e,(R+p)/2,t),I=Math.sign($[o]-x[o]),_=Math.sign(c[o]-$[o]);if(I!==_){x[o]>c[o]?(n.max.push(x),n.min.push(c)):(n.max.push(c),n.min.push(x)),s?x[o]>c[o]?(s.max.push(x[0],x[1]),s.min.push(c[0],c[1])):(s.max.push(c[0],c[1]),s.min.push(x[0],x[1])):(a.push(x[0],x[1]),t==="linear-horizontal"?a.push(NaN,(x[1]+c[1])/2):a.push((x[0]+c[0])/2,NaN),a.push(c[0],c[1]));break}}if(j===-1?x[o]<c[o]?R=x[M]:p=c[M]:x[o]>c[o]?R=x[M]:p=c[M],Math.abs(p-R)<w||v===E.extremumPass-1){j===-1&&x[o]>c[o]||j===1&&x[o]<c[o]?(n[k].push(x),s?s[k].push(x[0],x[1]):a.push(x[0],x[1])):(n[k].push(c),s?s[k].push(c[0],c[1]):a.push(c[0],c[1]));break}x=A(e,R+(p-R)/3,t),c=A(e,p-(p-R)/3,t)}else if(n.max.length+n.min.length>0){let v=null,$=0,I=!1;for(let _=0;_<=E.subsampling;_++){let T=_===0?l:_===E.subsampling?h:A(e,((E.subsampling-_)*l[M]+_*h[M])/E.subsampling,t);if(v){const B=Math.sign(T[o]-v[o]);if($&&B!==$){n[B===-1?"max":"min"].push(T),I=!0;break}$=B}v=T}I||(n.min.shift(),n.max.shift())}else n.min.shift(),n.max.shift();if(n.min.length>3&&n.min.shift(),n.max.length>3&&n.max.shift(),s){if(n.min.length<1&&n.max.length<1||P>r-g){if(s.min.length>2&&s.max.length>2){a.push(NaN,NaN);for(let v=0;v<s.min.length;v+=2)a.push(s.min[v],s.min[v+1]);t==="linear-horizontal"?(a.push(s.min[s.min.length-2],l[1]),a.push(s.max[s.max.length-2],l[1])):(a.push(l[0],s.min[s.min.length-1]),a.push(l[0],s.max[s.max.length-1]));for(let v=s.max.length-2;v>=0;v-=2)a.push(s.max[v],s.max[v+1]);a.push(NaN,NaN)}a.push(l[0],l[1]),s=null}}else if(n.min.length>=1&&n.max.length>=1){const v=n.min[n.min.length-1],$=n.max[n.max.length-1],I=Math.min(v[M],$[M]);s={min:t==="linear-horizontal"?[v[o],I]:[I,v[o]],max:t==="linear-horizontal"?[$[o],I]:[I,$[o]]}}}return a.push(h[0],h[1]),a},H=(e,t,i,f,r,g)=>{const m=[];for(let a=f;a<r;a+=g){const[l,N]=A(e,a,t);G(m,l,N,i,t)}return m},A=(e,t,i)=>{if(i==="parametric")return[e[0](t),e[1](t)];if(i==="polar"){const f=e[0](t);return[f*Math.cos(t),f*Math.sin(t)]}else{if(i==="linear-horizontal")return[e[0](t),t];if(i==="linear")return[t,e[0](t)]}throw new Error(`Unknown plot type ${i}`)},U=["line","dot","point"],q={};onmessage=({data:{index:e,funs:t,type:i,min:f,max:r,samples:g,region:m,affects:a,mode:l,rendering:N,recs:h,dimensions:M=2,uuid:o}})=>{let z="",u=[],b;try{if(i==="unknown")throw new Error(`Invalid function type ${t.join(", ")}`);if(!U.includes(l))throw new Error(`Invalid mode: ${l}, must be one of ${U.join(", ")}`);typeof f=="string"&&(f=new Function("return "+f)()),typeof r=="string"&&(r=new Function("return "+r)()),typeof g=="string"&&(g=new Function("return "+g)());const w=(r-f)/g;if(isNaN(w)||w===0)throw new Error(`Invalid step ${w}`);N||(["linear","linear-horizontal"].includes(i)?N="auto":N="size");for(let n=0;n<a.length;n++){const[d,P]=a[n],R=new Function("","return "+P)();q[d]=self[d],self[d]=R}h&&Object.entries(h).forEach(([n,d])=>{!d||(self[`$rec${n}`]=P=>{const R=~~Math.round(P*d.sampleRate);return R>=0&&R<d.buffer.length?d.buffer[R]:0})});const s=t.map(n=>new Function(Y[i],"return "+n));if(M===1){b=new Float32Array((r-f)/w);let n=0;for(let d=f;d<r;d+=w){const P=s[0](d);if(typeof P!="number"){let R;throw typeof P=="function"?R=new Error(self.__doc__[P]||"Function not supported"):typeof P>"u"?R=new Error(`${t[0]} is undefined`):R=new Error(`${typeof P} is not a number`),R}b[n++]=P}}else M===2&&(N==="size"?u=H(s,i,m,f,r,w):N==="adaptative"?u=X(s,i,m,f,r,w):N==="auto"&&(u=D(s,i,m,f,r,w)),b=new Float32Array(u));h&&Object.keys(h).forEach(n=>{delete self[`$rec${n}`]});for(let n=0;n<a.length;n++){const[d]=a[n];self[d]=q[d],delete q[d]}}catch(w){z=w}postMessage({index:e,values:b,type:i,mode:l,err:z,uuid:o},b==null?void 0:b.buffer)}})();

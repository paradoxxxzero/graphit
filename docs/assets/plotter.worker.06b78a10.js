(function(){"use strict";var C={sound:{adsr:"adsr usage: (x, attack = 0.2, decay = 0.1, sustain = 0.4, release = 0.3, sustainLevel = 0.5, duration = <sound duration>)",osc:"osc usage: (x, freq, type = sine|square|smoothsquare|sawtooth|triangle|noise, smooth = 0.5)",oscs:"oscs usage: (x, freqs, type = sine|square|smoothsquare|sawtooth|triangle|noise, smooth = 0.5)",sine:"sine usage: (x, freq)",square:"square usage: (x, freq)",smoothsquare:"smoothsquare usage: (x, freq, smooth = 0.5)",sawtooth:"sawtooth usage: (x, freq)",triangle:"triangle usage: (x, freq)",noise:"noise usage: (x)",lowpass:"lowpass usage: (x, input, cutoff)",highpass:"highpass usage: (x, input, cutoff)",segment:"segment usage: (x, ...pairs)",at:"at usage: (d, f, x)"},math:{abs:"Returns the absolute value of x.",acos:"Returns the arccosine of x.",acosh:"Returns the hyperbolic arccosine of x.",asin:"Returns the arcsine of x.",asinh:"Returns the hyperbolic arcsine of a number.",atan:"Returns the arctangent of x.",atanh:"Returns the hyperbolic arctangent of x.",atan2:"Returns the arctangent of the quotient of its arguments.",cbrt:"Returns the cube root of x.",ceil:"Returns the smallest integer greater than or equal to x.",clz32:"Returns the number of leading zero bits of the 32-bit integer x.",cos:"Returns the cosine of x.",cosh:"Returns the hyperbolic cosine of x.",exp:"Returns ex, where x is the argument, and e is Euler's constant (2.718\u2026, the base of the natural logarithm).",expm1:"Returns subtracting 1 from exp(x).",floor:"Returns the largest integer less than or equal to x.",fround:"Returns the nearest single precision float representation of x.",hypot:"Returns the square root of the sum of squares of its arguments.",imul:"Returns the result of the 32-bit integer multiplication of x and y.",log:"Returns the natural logarithm (\u33D2e; also, \u33D1) of x.",log1p:"Returns the natural logarithm (\u33D2e; also \u33D1) of 1 + x for the number x.",log10:"Returns the base-10 logarithm of x.",log2:"Returns the base-2 logarithm of x.",max:"Returns the largest of zero or more numbers.",min:"Returns the smallest of zero or more numbers.",pow:"Returns base x to the exponent power y (that is, xy).",random:"Returns a pseudo-random number between 0 and 1.",round:"Returns the value of the number x rounded to the nearest integer.",sign:"Returns the sign of the x, indicating whether x is positive, negative, or zero.",sin:"Returns the sine of x.",sinh:"Returns the hyperbolic sine of x.",sqrt:"Returns the positive square root of x.",tan:"Returns the tangent of x.",tanh:"Returns the hyperbolic tangent of x.",trunc:"Returns the integer portion of x, removing any fractional digits."},constant:{e:"Euler's constant and the base of natural logarithms; approximately 2.718.",ln2:"Natural logarithm of 2; approximately 0.693.",ln10:"Natural logarithm of 10; approximately 2.303.",log2e:"Base-2 logarithm of E; approximately 1.443.",log10e:"Base-10 logarithm of E; approximately 0.434.",pi:"Ratio of a circle's circumference to its diameter; approximately 3.14159.",sqrt1_2:"Square root of \xBD; approximately 0.707.",sqrt2:"Square root of 2; approximately 1.414."},util:{lerp:"lerp usage: (x, y, a)",clamp:"clamp usage: (x, min, max)"},graphit:{"@size":"Plot each pixel","@adaptative":"Adaptative plot","@auto":"Better adaptative plot","@fft":"FFT of the sound","@!":"Precision","@/dot":"Dot plot mode","@/point":"Point plot mode","@/line":"Line plot mode","@ ":"@ x0 -> x1 : Plot range [x0;x1]"}};const S=t=>t&t-1?2**(Math.log2(t)+1|0):t,D={linear:"x","linear-horizontal":"y",polar:"o",parametric:"t",sound:"t",fft:"t"};self.lerp=(t,e,s)=>t+(e-t)*s,self.clamp=(t,e,s)=>Math.min(Math.max(t,e),s);for(let t of Array.from(Object.getOwnPropertyNames(Math)))self[t.toLowerCase()]=self[t]=Math[t];const G=self.PI,A=self.tau=self.TAU=G*2;self.eta=self.ETA=G/2,self.ln=self.log,self.osc=(t,e,s="sine",f=.5)=>{const o=++self._state.call;if(self._state.n<0)return 0;self._state[o]||(self._state[o]={f:0,last_x:0});const n=self._state[o],l=t-n.last_x;n.last_x=t;const a=n.f+=self.clamp(e,0,22050)*l;switch(s){case"sine":return Math.sin(a*A);case"square":return Math.sign(Math.sin(a*A));case"smoothsquare":return Math.tanh(Math.sin(a*A)/f);case"sawtooth":return a%1*2-1;case"triangle":return Math.abs(a%1*4-2)-1;case"noise":return Math.random()*2-1;default:throw new Error(`Unknown oscillator type: ${s}`)}},self.sine=(t,e)=>self.osc(t,e,"sine"),self.square=(t,e)=>self.osc(t,e,"square"),self.smoothsquare=(t,e,s=.5)=>self.osc(t,e,"smoothsquare",s),self.sawtooth=(t,e)=>self.osc(t,e,"sawtooth"),self.triangle=(t,e)=>self.osc(t,e,"triangle"),self.noise=()=>self.osc(0,0,"noise"),self.oscs=(t,e,s,f=.5)=>{let o=0;e=Array.isArray(e)?e:[e];for(let n=0;n<e.length;n++)o+=self.osc(t,e[n],s,f);return o/e.length},self.adsr=(t,e=.2,s=.1,f=.4,o=.3,n=.5,l=null)=>(l=l||self._state.max,t=t/l,t<0?0:t<=e?t/e:t<=e+s?1-(1-n)*(t-e)/s:t<=e+s+f?n:t<=e+s+f+o?n-(n-0)*(t-e-s-f)/o:0),self.iirFilterGen=t=>(e,s,f)=>{const o=++self._state.call;if(self._state.n<0)return 0;if(!self._state[o]){const[i,u]=t(s,f);self._state[o]={a:i,b:u,x:new Array(i.length).fill(0),y:new Array(u.length).fill(0)}}const n=self._state[o],{a:l,b:a,x:r,y:m}=n;let c=0;for(let i=0;i<l.length;i++)c+=l[i]*r[i];for(let i=0;i<a.length;i++)c+=a[i]*m[i];for(let i=l.length-1;i>0;i--)r[i]=r[i-1];for(let i=a.length-1;i>0;i--)m[i]=m[i-1];return r[0]=e,m[0]=c,c},self.lowpass=self.iirFilterGen(t=>{const e=t*self._state.step,s=Math.exp(-A*e);return[[1-s],[s]]}),self.lowpass4=self.iirFilterGen(t=>{const s=t*self._state.step,f=Math.exp(-14.445*s);return[[Math.pow(1-f,4)],[4*f,-6*Math.pow(f,2),4*Math.pow(f,3),-Math.pow(f,4)]]}),self.highpass=self.iirFilterGen(t=>{const e=t*self._state.step,s=Math.exp(-A*e);return[[(1+s)/2,-(1+s)/2],[s]]}),self.bandpass=self.iirFilterGen((t,e)=>{const s=t*self._state.step,f=e*self._state.step,o=2*Math.cos(A*s),n=1-3*f,l=(1-n*o+n*n)/(2-o);return[[1-l,(l-n)*o,n*n-l],[n*o,-n*n]]}),self.bandreject=self.iirFilterGen((t,e)=>{const s=t*self._state.step,f=e*self._state.step,o=2*Math.cos(A*s),n=1-3*f,l=(1-n*o+n*n)/(2-o);return[[l,-l*o,l],[n*o,-n*n]]}),self.pulse=()=>{const t=++self._state.call;return self._state.n<0||self._state[t]?0:(self._state[t]=!0,1)},self.peak=(t,e,s=1)=>t===e?s:0,self.fft=(t,e)=>{const s=t.length;if(s!==e.length)throw new Error("Mismatched lengths");const f=Math.log2(s);if(f!==~~f)throw new Error("Length is not a power of 2");const o=new Float32Array(s/2),n=new Float32Array(s/2);for(var l=0;l<s/2;l++)o[l]=Math.cos(A*l/s),n[l]=Math.sin(A*l/s);for(let a=0;a<s;a++){let r=0,m=a;for(let c=0;c<f;c++)r=r<<1|m&1,m>>>=1;r>a&&([t[a],t[r]]=[t[r],t[a]],[e[a],e[r]]=[e[r],e[a]])}for(let a=2;a<=s;a*=2){const r=a/2,m=s/a;for(let c=0;c<s;c+=a)for(let i=c,u=0;i<c+r;i++,u+=m){const w=t[i+r]*o[u]+e[i+r]*n[u],x=-t[i+r]*n[u]+e[i+r]*o[u];t[i+r]=t[i]-w,e[i+r]=e[i]-x,t[i]+=w,e[i]+=x}}return[t,e]},self.segment=(t,...e)=>{for(let s=0;s<e.length;s+=2)if(t<e[s])return e[s+1]},self.at=(t,e,s)=>e(s+t),self.__doc__=Object.fromEntries(Object.entries(C).map(([t,e])=>Object.entries(e).map(([s,f])=>[self[s],`${t}: ${f}`])).flat());const q={epsilon:1e-9,sampling:1500,subsampling:32,minBlockSize:10,precisionPass:8,precision:G/1024,extremumPass:32,straightness:1e-5,maxPoints:1e4,overflow:.1},U=(t,e,s,f,o)=>{var n,l;if(isNaN(e)||isNaN(s)||e<f[0][0]||e>f[0][1]||s<f[1][0]||s>f[1][1]){(n=t.out)!=null&&n.length||t.length>0&&t.push(e,s),t.out=[e,s];return}(l=t.out)!=null&&l.length&&(o==="linear-horizontal"?t.push(NaN,((t[t.length-1]||f[1][0])+t.out[1])/2):o==="linear"?t.push(((t[t.length-2]||f[0][0])+t.out[0])/2,NaN):t.push(NaN,NaN),t.push(...t.out),t.out.splice(0)),t.push(e,s)},V=(t,e,s,f,o,n,l,a)=>{if(s==="linear"){const r=a*f+(1-a)*n,m=e[0](r);t(r,m)}else if(s==="linear-horizontal"){const r=a*o+(1-a)*l,m=e[0](r);t(m,r)}},L=(t,e,s,f,o)=>{const[[n,l],[a,r]]=f,m=[],c=(x,N)=>U(m,x,N,f,s),i=(x,N,R,h,g)=>V(c,e,s,x,N,R,h,g),u=(r-a)/(l-n);let w=0;for(let x=0;x+w<t.length;x+=4){const N=t[x],R=t[x+1],h=t[x+2+w],g=t[x+3+w],d=t[x+4+w],p=t[x+5+w];if(s==="linear"&&(isNaN(R)||isNaN(g)||isNaN(p))||s==="linear-horizontal"&&(isNaN(N)||isNaN(h)||isNaN(d))){x+=w,w=0,c(N,R),c(h,g);continue}const z=Math.atan2(g-R,u*(h-N)),M=Math.atan2(p-g,u*(d-h))-z,b=Math.abs(M),B=((d-N)/(l-n))**2+((p-R)/(r-a))**2;if(b*B<q.straightness){x-=4,w+=2;continue}if(w&&(x+=w,w=0),o){c(N,R),c(h,g);continue}const k=b>q.precision;c(N,R),k&&i(N,R,h,g,1/2),c(h,g),k&&i(h,g,d,p,1/2)}return m},X=(t,e,s,f)=>{for(let o=2;o<t.length-2;o+=2){let n=t[o-2],l=t[o-1],a=t[o],r=t[o+1],m=t[o+2],c=t[o+3];const i=f[s==="linear-horizontal"?0:1];if(s==="linear-horizontal"&&([n,l]=[l,n],[a,r]=[r,a],[m,c]=[c,m]),isNaN(r)||isNaN(c)||isNaN(l))continue;const u=Math.sign(r-l),w=Math.sign(c-r);if(u!==w){let x=n,N=a,R=m,h=r;for(let g=0;g<q.extremumPass;g++){const d=(x+N)/2,p=e[0](d),z=(N+R)/2,P=e[0](z);if(Math.sign(p-h)===u?(R=N,N=d,h=p):Math.sign(P-h)===u?(x=N,N=z,h=P):(x=d,R=z),x===R||h>i[1]||h<i[0])break}t[o]=N,t[o+1]=h,s==="linear-horizontal"&&([t[o],t[o+1]]=[t[o+1],t[o]])}}},H=(t,e,s,f,o,n)=>{let l=[];for(let a=f;a<o;a+=n){const[r,m]=v(t,e,a);U(l,r,m,s,e)}l=L(l,t,e,s,!0),X(l,t,e,s);for(let a=0;a<q.precisionPass&&!(l.length>q.maxPoints);a++)l=L(l,t,e,s);return l},J=(t,e,s,f,o,n)=>{const l=o-f;f-=l*q.overflow/2,o+=l*q.overflow/2;const a=[];let r=[NaN,NaN],m=[NaN,NaN],c=v(t,e,f);const[i,u]=e==="linear-horizontal"?[1,0]:[0,1],w=s[e==="linear-horizontal"?0:1],x=s[e==="linear-horizontal"?1:0],N=(w[1]-w[0])/(x[1]-x[0]),R=(x[1]-x[0])*q.epsilon;let h=null,g={min:[],max:[]},d=!1;for(let p=f;p<=o;p+=n){if(m=r,r=c,c=v(t,e,p+n),isNaN(r[u])||isNaN(c[u])){a.push(r[0],r[1]);continue}if(!isNaN(m[u])&&!h&&p<o-n){const _=Math.atan2(r[u]-m[u],N*(r[i]-m[i])),y=Math.atan2(c[u]-r[u],N*(c[i]-r[i]))-_,F=Math.abs(y),T=((c[i]-m[i])/(x[1]-x[0]))**2+((c[u]-m[u])/(w[1]-w[0]))**2;if(F*T<q.straightness){d=!0,r=m;continue}else d&&(d=!1,p-=n,c=r,r=m)}h||a.push(r[0],r[1]);let z=r[i],P=c[i],M=v(t,e,z+(P-z)/3),b=v(t,e,P-(P-z)/3);const B=Math.sign(M[u]-r[u]),k=Math.sign(b[u]-M[u]),$=Math.sign(c[u]-b[u]),j=$===-1?"max":"min";if(B!==k||k!==$)for(let _=0;_<q.extremumPass;_++){if(M[u]>w[1]&&b[u]<w[0]||M[u]<w[0]&&b[u]>w[1]){const E=v(t,e,(z+P)/2),y=Math.sign(E[u]-M[u]),F=Math.sign(b[u]-E[u]);if(y!==F){M[u]>b[u]?(g.max.push(M),g.min.push(b)):(g.max.push(b),g.min.push(M)),h?M[u]>b[u]?(h.max.push(M[0],M[1]),h.min.push(b[0],b[1])):(h.max.push(b[0],b[1]),h.min.push(M[0],M[1])):(a.push(M[0],M[1]),e==="linear-horizontal"?a.push(NaN,(M[1]+b[1])/2):a.push((M[0]+b[0])/2,NaN),a.push(b[0],b[1]));break}}if($===-1?M[u]<b[u]?z=M[i]:P=b[i]:M[u]>b[u]?z=M[i]:P=b[i],Math.abs(P-z)<R||_===q.extremumPass-1){$===-1&&M[u]>b[u]||$===1&&M[u]<b[u]?(g[j].push(M),h?h[j].push(M[0],M[1]):a.push(M[0],M[1])):(g[j].push(b),h?h[j].push(b[0],b[1]):a.push(b[0],b[1]));break}M=v(t,e,z+(P-z)/3),b=v(t,e,P-(P-z)/3)}else if(g.max.length+g.min.length>0){let _=null,E=0,y=!1;for(let F=0;F<=q.subsampling;F++){let T=F===0?r:F===q.subsampling?c:v(t,e,((q.subsampling-F)*r[i]+F*c[i])/q.subsampling);if(_){const I=Math.sign(T[u]-_[u]);if(E&&I!==E){g[I===-1?"max":"min"].push(T),y=!0;break}E=I}_=T}y||(g.min.shift(),g.max.shift())}else g.min.shift(),g.max.shift();if(g.min.length>3&&g.min.shift(),g.max.length>3&&g.max.shift(),h){if(g.min.length<1&&g.max.length<1||p>o-n){if(h.min.length>2&&h.max.length>2){a.push(NaN,NaN);for(let _=0;_<h.min.length;_+=2)a.push(h.min[_],h.min[_+1]);e==="linear-horizontal"?(a.push(h.min[h.min.length-2],r[1]),a.push(h.max[h.max.length-2],r[1])):(a.push(r[0],h.min[h.min.length-1]),a.push(r[0],h.max[h.max.length-1]));for(let _=h.max.length-2;_>=0;_-=2)a.push(h.max[_],h.max[_+1]);a.push(NaN,NaN)}a.push(r[0],r[1]),h=null}}else if(g.min.length>=1&&g.max.length>=1){const _=g.min[g.min.length-1],E=g.max[g.max.length-1],y=Math.min(_[i],E[i]);h={min:e==="linear-horizontal"?[_[u],y]:[y,_[u]],max:e==="linear-horizontal"?[E[u],y]:[y,E[u]]}}}return a.push(c[0],c[1]),a},Q=(t,e,s,f,o,n)=>{const l=[];for(let a=f;a<o;a+=n){const[r,m]=v(t,e,a);l.push(r,m)}return l},W=(t,e,s,f,o,n)=>{const l=S((o-f)/(o*n)),a=[],r=[],m=[];for(let w=0;w<l;w++){const[,x]=v(t,e,w*n);r.push(x),m.push(0)}self.fft(r,m);const c=2/l,i=c/(2*n),u=Math.max(1,~~(l/s[0][2]));for(let w=0;w<l/2;w++){let x=w,N=0;for(;w-x<u;w++)N=Math.max(N,c*Math.sqrt(r[w]**2+m[w]**2));a.push(i*(x+w+1)/2,N)}return a},K=(t,e,s,f,o,n)=>{const l=S((o-f)/(o*n)),a=[],r=[],m=[];for(let c=0;c<l;c++){const[,i]=v(t,e,c);r.push(0),m.push(i)}self.fft(r,m);for(let c=0;c*n<o;c++)a.push(c*n,r[c]);return a},v=(t,e,s)=>{if(self._state.call=0,self._state.n=s,e==="parametric"){const f=t[0](s),o=t[1](s);return[f,o]}else if(e==="polar"){const f=t[0](s);return[f*Math.cos(s),f*Math.sin(s)]}else{if(e==="linear-horizontal")return[t[0](s),s];if(["linear","sound","fft","ifft"].includes(e)){const f=t[0](s);return[s,f]}}throw new Error(`Unknown plot type ${e}`)},Y=["line","dot","point"],O={};onmessage=({data:{index:t,region:e,affects:s,funs:f,type:o,min:n,max:l,samples:a,mode:r,rendering:m,recs:c,job:i,uuid:u}})=>{let w="",x=[],N,R;try{if(o==="unknown")throw new Error(`Invalid function type ${f.join(", ")}`);if(!Y.includes(r))throw new Error(`Invalid mode: ${r}, must be one of ${Y.join(", ")}`);typeof n=="string"&&(n=new Function("return "+n)()),typeof l=="string"&&(l=new Function("return "+l)()),typeof a=="string"&&(a=new Function("return "+a)());const h=(l-n)/a;if(isNaN(h)||h===0)throw new Error(`Invalid step ${h}`);m||(["linear","linear-horizontal"].includes(o)?m="auto":m="size");for(let d=0;d<s.length;d++){const[p,z]=s[d],P=new Function("","return "+z)();O[p]=self[p],self[p]=P}c&&Object.entries(c).forEach(([d,p])=>{!p||(self[`$rec${d}`]=z=>{const P=~~Math.round(z*p.sampleRate);return P>=0&&P<p.buffer.length?p.buffer[P]:0})}),self._state={call:0,min:n,max:l,step:h};const g=f.map(d=>new Function(D[o],"return "+d));if(i==="check"){self._state.call=self._state.n=0;const d=g[0](Math.random()*(l-n)+n);if(typeof d!="number"){let p;throw typeof d=="function"?p=new Error(self.__doc__[d]||"Function not supported"):typeof d>"u"?p=new Error(`${f[0]} is undefined`):p=new Error(`${typeof d} is not a number`),p}o==="sound"?m==="fft"?N=[[0,a/l/2,e[0][2]],[0,1,e[1][2]]]:N=[[0,l,e[0][2]],[-1,1,e[1][2]]]:N=[[-2,2,e[0][2]],[-2*e[1][2]/e[0][2],2*e[1][2]/e[0][2],e[1][2]]]}else if(i==="sound"){R=new Float32Array((l-n)/h);let d=0;if(m==="ifft"){x=K(g,o,e,n,l,h);for(let p=1;p<x.length;p+=2)R[d++]=x[p]}else for(let p=n;p<l;p+=h)self._state.call=0,self._state.n=p,R[d++]=g[0](p)}else m==="size"?x=Q(g,o,e,n,l,h):m==="adaptative"?x=H(g,o,e,n,l,h):m==="auto"?x=J(g,o,e,n,l,h):m==="fft"?x=W(g,o,e,n,l,h):m==="ifft"&&(x=K(g,o,e,n,l,h)),R=new Float32Array(x);c&&Object.keys(c).forEach(d=>{delete self[`$rec${d}`]});for(let d=0;d<s.length;d++){const[p]=s[d];self[p]=O[p],delete O[p]}}catch(h){w=h}postMessage({index:t,values:R,type:o,mode:r,max:l,samples:a,rendering:m,preferredRegion:N,err:w,uuid:u},R==null?void 0:R.buffer)}})();
